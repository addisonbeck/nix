#+TITLE: Jira Configuration
#+PROPERTY: header-args:emacs-lisp :tangle jira.el :results none

These wrapper functions provide a programmatic interface to the jira cli. 
- Most functions use `shell-command` for interactive operations and `shell-command-to-string` for data retrieval
- Interactive prompts are handled by the underlying jira cli when parameters are omitted
- Optional parameters allow for scriptable, non-interactive usage
- Error handling is delegated to the jira cli tool itself
- All functions require the jira cli to be installed and configured (`jira init`)

To use these functions, first ensure you have:
1. jira cli installed and in your PATH
2. Run `jira init` to configure authentication
3. Load this file or tangle it to jira.el and require it

Example usage:
- `(jira-issue-list "--created week -a$(jira me)")` - List your issues from this week
- `(jira-issue-view "PROJ-123" 5)` - View issue with 5 recent comments
- `(jira-epic-list nil "--table")` - List epics in table format

* Issue Operations

The core functionality for working with Jira issues - listing, viewing, creating and editing tickets.

** List Issues

Basic function to list issues with optional filtering parameters. Returns the raw output from jira cli.

#+begin_src emacs-lisp
;; Required libraries for enhanced functionality
(require 'json)
(require 'seq)

(defun jira-issue-list (&optional args)
  "List Jira issues with optional ARGS for filtering.
ARGS can be a string of jira cli flags like '--created week -a$(jira me)'."
  (interactive)
  (let ((cmd (if args
                 (format "jira issue list %s" args)
               "jira issue list")))
    (shell-command-to-string cmd)))
#+end_src

** View Issue Details

Enhanced issue viewer that combines human-readable formatting with comprehensive information from the raw API.

#+begin_src emacs-lisp
(defun jira-issue-view (issue-key &optional comments)
  "View details for ISSUE-KEY in a dedicated buffer with enhanced formatting.
Combines raw JSON data with human-readable presentation.
Optional COMMENTS specifies number of recent comments to show."
  (interactive "sIssue key: ")
  (let ((buffer-name (format "*Jira: %s*" issue-key)))
    (with-current-buffer (get-buffer-create buffer-name)
      (when (bound-and-true-p view-mode)
        (view-mode -1))
      (erase-buffer)
      
      ;; Get both plain view for description and raw JSON for metadata
      (let* ((raw-json (shell-command-to-string (format "jira issue view %s --raw" issue-key)))
             (plain-view (shell-command-to-string 
                         (if comments
                             (format "jira issue view %s --plain --comments %s" issue-key comments)
                           (format "jira issue view %s --plain" issue-key))))
             (json-data (ignore-errors (json-parse-string raw-json :object-type 'alist :array-type 'list))))
        
        (if json-data
            (jira--format-enhanced-issue json-data plain-view)
          ;; Fallback to plain view if JSON parsing fails
          (insert plain-view)
          (ansi-color-apply-on-region (point-min) (point-max))))
      
      (goto-char (point-min))
      (view-mode 1))
    (switch-to-buffer buffer-name)))

(defun jira--format-enhanced-issue (json-data plain-view)
  "Format issue data with enhanced human-readable information."
  (let* ((fields (alist-get 'fields json-data))
         (issue-key (alist-get 'key json-data))
         (summary (alist-get 'summary fields))
         (status (alist-get 'name (alist-get 'status fields)))
         (priority (alist-get 'name (alist-get 'priority fields)))
         (issue-type (alist-get 'name (alist-get 'issuetype fields)))
         (assignee (alist-get 'displayName (alist-get 'assignee fields)))
         (reporter (alist-get 'displayName (alist-get 'reporter fields)))
         (created (alist-get 'created fields))
         (updated (alist-get 'updated fields))
         (labels (alist-get 'labels fields))
         (comments (alist-get 'comments (alist-get 'comment fields)))
         (comment-total (alist-get 'total (alist-get 'comment fields)))
         (attachments (alist-get 'attachment fields))
         (issue-links (alist-get 'issuelinks fields))
         (parent (alist-get 'parent fields))
         (sprint-data (alist-get 'customfield_10020 fields))
         (watchers (alist-get 'watchCount (alist-get 'watches fields))))
    
    ;; Header with key info and URL
    (insert (format "ðŸŽ« %s: %s\n" issue-key summary))
    (insert (format "ðŸ”— %s\n" (alist-get 'self json-data)))
    (insert (make-string (+ 4 (length issue-key) (length summary)) ?=) "\n\n")
    
    ;; Status and metadata section
    (insert "ðŸ“Š STATUS & METADATA\n")
    (insert (make-string 20 ?-) "\n")
    (insert (format "   Status: %s\n" (or status "Unknown")))
    (insert (format "   Type: %s\n" (or issue-type "Unknown")))
    (insert (format "   Priority: %s\n" (or priority "None")))
    (insert (format "   Assignee: %s\n" (or assignee "Unassigned")))
    (insert (format "   Reporter: %s\n" (or reporter "Unknown")))
    (when watchers
      (insert (format "   Watchers: %s\n" watchers)))
    
    ;; Sprint information
    (when (and sprint-data (listp sprint-data))
      (insert "\nðŸƒ SPRINT INFORMATION\n")
      (insert (make-string 20 ?-) "\n")
      (let ((active-sprint (seq-find (lambda (s) (string= (alist-get 'state s) "active")) sprint-data)))
        (if active-sprint
            (insert (format "   Current: %s (Active)\n" (alist-get 'name active-sprint)))
          (let ((recent-sprint (car sprint-data)))
            (when recent-sprint
              (insert (format "   Recent: %s (%s)\n" 
                            (alist-get 'name recent-sprint)
                            (capitalize (alist-get 'state recent-sprint)))))))))
    
    ;; Labels and links
    (when (or labels parent issue-links)
      (insert "\nðŸ·ï¸  RELATIONSHIPS\n")
      (insert (make-string 20 ?-) "\n")
      (when labels
        (insert (format "   Labels: %s\n" (string-join (mapcar (lambda (l) (format "#%s" l)) labels) " "))))
      (when parent
        (insert (format "   Parent: %s - %s\n" 
                       (alist-get 'key parent)
                       (alist-get 'summary (alist-get 'fields parent)))))
      (when issue-links
        (dolist (link issue-links)
          (let* ((type (alist-get 'type link))
                 (type-name (alist-get 'name type))
                 (outward (alist-get 'outwardIssue link))
                 (inward (alist-get 'inwardIssue link)))
            (cond
             (outward 
              (insert (format "   %s: %s - %s\n" 
                            type-name
                            (alist-get 'key outward)
                            (alist-get 'summary (alist-get 'fields outward)))))
             (inward
              (insert (format "   %s: %s - %s\n"
                            (alist-get 'inward type)
                            (alist-get 'key inward)
                            (alist-get 'summary (alist-get 'fields inward))))))))))
    
    ;; Comments and attachments
    (when (or (and comment-total (> comment-total 0)) attachments)
      (insert "\nðŸ’¬ ACTIVITY\n")
      (insert (make-string 20 ?-) "\n")
      (when comment-total
        (insert (format "   Comments: %s total\n" comment-total)))
      (when attachments
        (insert (format "   Attachments: %s files\n" (length attachments)))
        (dolist (att attachments)
          (let* ((filename (alist-get 'filename att))
                 (size (alist-get 'size att))
                 (size-mb (if size (format "%.1fMB" (/ size 1048576.0)) "unknown size")))
            (insert (format "     ðŸ“Ž %s (%s)\n" filename size-mb))))))
    
    ;; Description section
    (insert "\nðŸ“ DESCRIPTION\n")
    (insert (make-string 20 ?-) "\n")
    (let ((description (alist-get 'description fields)))
      (if (and description (alist-get 'content description))
          ;; Parse Atlassian document format
          (jira--format-comment-content (alist-get 'content description))
        ;; Fallback to plain view description extraction
        (let ((desc-start (string-match "-+[ ]*Description[ ]*-+" plain-view)))
          (if desc-start
              (let* ((desc-content (substring plain-view desc-start))
                     (next-section (string-match "-+[ ]*[A-Za-z ]*[ ]*-+" desc-content 1)))
                (insert (if next-section 
                           (substring desc-content 0 next-section)
                         desc-content)))
            (insert "No description available.\n")))))
    
    ;; Apply ANSI coloring to the whole buffer
    (ansi-color-apply-on-region (point-min) (point-max))))
#+end_src

** Create Issue

Create a new Jira issue with interactive prompts or specified parameters.

#+begin_src emacs-lisp
(defun jira-issue-create (&optional type summary priority labels body no-input)
  "Create a new Jira issue.
TYPE: issue type (e.g., 'Bug', 'Task', 'Story')
SUMMARY: issue summary/title
PRIORITY: issue priority (e.g., 'High', 'Medium', 'Low')  
LABELS: comma-separated list of labels
BODY: issue description
NO-INPUT: if t, skip interactive prompts"
  (interactive)
  (let ((cmd "jira issue create"))
    (when type (setq cmd (format "%s -t%s" cmd type)))
    (when summary (setq cmd (format "%s -s\"%s\"" cmd summary)))
    (when priority (setq cmd (format "%s -y%s" cmd priority)))
    (when labels (setq cmd (format "%s -l%s" cmd labels)))
    (when body (setq cmd (format "%s -b\"%s\"" cmd body)))
    (when no-input (setq cmd (format "%s --no-input" cmd)))
    (shell-command cmd)))
#+end_src

** Edit Issue

Edit an existing Jira issue.

#+begin_src emacs-lisp
(defun jira-issue-edit (issue-key &optional summary priority labels body no-input)
  "Edit ISSUE-KEY with optional parameters.
SUMMARY: new summary/title
PRIORITY: new priority 
LABELS: new labels (use -label to remove)
BODY: new description
NO-INPUT: if t, skip interactive prompts"
  (interactive "sIssue key: ")
  (let ((cmd (format "jira issue edit %s" issue-key)))
    (when summary (setq cmd (format "%s -s\"%s\"" cmd summary)))
    (when priority (setq cmd (format "%s -y%s" cmd priority)))
    (when labels (setq cmd (format "%s -l%s" cmd labels)))
    (when body (setq cmd (format "%s -b\"%s\"" cmd body)))
    (when no-input (setq cmd (format "%s --no-input" cmd)))
    (shell-command cmd)))
#+end_src

** Assign Issue

Assign a Jira issue to a user.

#+begin_src emacs-lisp
(defun jira-issue-assign (issue-key assignee)
  "Assign ISSUE-KEY to ASSIGNEE.
ASSIGNEE can be a username, 'default' for default assignee, or 'x' to unassign."
  (interactive "sIssue key: \nsAssignee (username, 'default', or 'x' to unassign): ")
  (let ((cmd (format "jira issue assign %s \"%s\"" issue-key assignee)))
    (shell-command cmd)))
#+end_src

** Move/Transition Issue

Move an issue from one state to another.

#+begin_src emacs-lisp
(defun jira-issue-move (issue-key status &optional comment resolution assignee)
  "Move ISSUE-KEY to STATUS.
Optional COMMENT to add during transition.
Optional RESOLUTION to set.
Optional ASSIGNEE to assign during move."
  (interactive "sIssue key: \nsNew status: ")
  (let ((cmd (format "jira issue move %s \"%s\"" issue-key status)))
    (when comment (setq cmd (format "%s --comment \"%s\"" cmd comment)))
    (when resolution (setq cmd (format "%s -R%s" cmd resolution)))
    (when assignee (setq cmd (format "%s -a%s" cmd assignee)))
    (shell-command cmd)))
#+end_src

** Clone Issue

Clone an existing issue with optional modifications.

#+begin_src emacs-lisp
(defun jira-issue-clone (issue-key &optional summary priority assignee labels replace-text)
  "Clone ISSUE-KEY with optional modifications.
SUMMARY: new summary for cloned issue
PRIORITY: new priority 
ASSIGNEE: new assignee
LABELS: new labels
REPLACE-TEXT: find:replace pattern for summary/description"
  (interactive "sIssue key to clone: ")
  (let ((cmd (format "jira issue clone %s" issue-key)))
    (when summary (setq cmd (format "%s -s\"%s\"" cmd summary)))
    (when priority (setq cmd (format "%s -y%s" cmd priority)))
    (when assignee (setq cmd (format "%s -a%s" cmd assignee)))
    (when labels (setq cmd (format "%s -l%s" cmd labels)))
    (when replace-text (setq cmd (format "%s -H\"%s\"" cmd replace-text)))
    (shell-command cmd)))
#+end_src

** Delete Issue

Delete a Jira issue.

#+begin_src emacs-lisp
(defun jira-issue-delete (issue-key &optional cascade)
  "Delete ISSUE-KEY.
If CASCADE is t, also delete all subtasks."
  (interactive "sIssue key to delete: ")
  (let ((cmd (format "jira issue delete %s" issue-key)))
    (when cascade (setq cmd (format "%s --cascade" cmd)))
    (shell-command cmd)))
#+end_src

* Issue Linking and Comments

Functions for linking issues together and managing comments.

** Link Issues

Link two issues together with a relationship type.

#+begin_src emacs-lisp
(defun jira-issue-link (from-issue to-issue link-type)
  "Link FROM-ISSUE to TO-ISSUE with LINK-TYPE.
LINK-TYPE examples: 'Blocks', 'Relates to', 'Duplicates'."
  (interactive "sFrom issue: \nsTo issue: \nsLink type: ")
  (let ((cmd (format "jira issue link %s %s \"%s\"" from-issue to-issue link-type)))
    (shell-command cmd)))
#+end_src

** Add Remote Link

Add a remote web link to an issue.

#+begin_src emacs-lisp
(defun jira-issue-link-remote (issue-key url title)
  "Add remote web link to ISSUE-KEY.
URL: the web URL to link
TITLE: display text for the link"
  (interactive "sIssue key: \nsURL: \nsLink title: ")
  (let ((cmd (format "jira issue link remote %s \"%s\" \"%s\"" issue-key url title)))
    (shell-command cmd)))
#+end_src

** Unlink Issues

Remove link between two issues.

#+begin_src emacs-lisp
(defun jira-issue-unlink (from-issue to-issue)
  "Unlink FROM-ISSUE and TO-ISSUE."
  (interactive "sFrom issue: \nsTo issue: ")
  (let ((cmd (format "jira issue unlink %s %s" from-issue to-issue)))
    (shell-command cmd)))
#+end_src

** Add Comment

Add a comment to an issue.

#+begin_src emacs-lisp
(defun jira-issue-comment-add (issue-key comment &optional internal template)
  "Add COMMENT to ISSUE-KEY.
INTERNAL: if t, make comment internal
TEMPLATE: path to template file or '-' for stdin"
  (interactive "sIssue key: \nsComment: ")
  (let ((cmd (format "jira issue comment add %s" issue-key)))
    (cond
     (template (setq cmd (format "%s --template \"%s\"" cmd template)))
     (comment (setq cmd (format "%s \"%s\"" cmd comment))))
    (when internal (setq cmd (format "%s --internal" cmd)))
    (shell-command cmd)))
#+end_src

** Add Worklog

Add time logging to an issue.

#+begin_src emacs-lisp
(defun jira-issue-worklog-add (issue-key time-spent &optional comment no-input)
  "Add worklog to ISSUE-KEY for TIME-SPENT.
TIME-SPENT: duration like '2d 3h 30m' or '1h 15m'
COMMENT: optional comment for the worklog
NO-INPUT: if t, skip interactive prompts"
  (interactive "sIssue key: \nsTime spent (e.g., '2h 30m'): ")
  (let ((cmd (format "jira issue worklog add %s \"%s\"" issue-key time-spent)))
    (when comment (setq cmd (format "%s --comment \"%s\"" cmd comment)))
    (when no-input (setq cmd (format "%s --no-input" cmd)))
    (shell-command cmd)))
#+end_src

** View Comments

Enhanced comment viewing with structured display.

#+begin_src emacs-lisp
(defun jira-issue-comments (issue-key &optional count)
  "View comments for ISSUE-KEY in a dedicated buffer with enhanced formatting.
COUNT specifies number of recent comments to show (default 10)."
  (interactive "sIssue key: ")
  (let* ((comment-count (or count 10))
         (buffer-name (format "*Jira Comments: %s*" issue-key))
         (raw-json (shell-command-to-string (format "jira issue view %s --raw" issue-key)))
         (json-data (ignore-errors (json-parse-string raw-json :object-type 'alist :array-type 'list))))
    
    (with-current-buffer (get-buffer-create buffer-name)
      (when (bound-and-true-p view-mode)
        (view-mode -1))
      (erase-buffer)
      
      (if json-data
          (let* ((fields (alist-get 'fields json-data))
                 (comment-data (alist-get 'comment fields))
                 (comments (alist-get 'comments comment-data))
                 (total (alist-get 'total comment-data))
                 (summary (alist-get 'summary fields)))
            
            ;; Header
            (insert (format "ðŸ’¬ Comments for %s: %s\n" issue-key summary))
            (insert (make-string (+ 15 (length issue-key) (length summary)) ?=) "\n\n")
            (insert (format "Total comments: %d\n" (or total 0)))
            (when (> (or total 0) 0)
              (insert (format "Showing: %d most recent\n" (min comment-count (or total 0)))))
            (insert "\n" (make-string 50 ?-) "\n\n")
            
            (if (and comments (> (length comments) 0))
                (let ((recent-comments (seq-take (reverse comments) comment-count)))
                  (dolist (comment recent-comments)
                    (let* ((author (alist-get 'displayName (alist-get 'author comment)))
                           (created (alist-get 'created comment))
                           (body (alist-get 'body comment))
                           (created-date (when created
                                          (format-time-string "%Y-%m-%d %H:%M" 
                                                            (date-to-time created)))))
                      (insert (format "ðŸ‘¤ %s" (or author "Unknown Author")))
                      (when created-date
                        (insert (format " â€¢ %s" created-date)))
                      (insert "\n" (make-string 40 ?-) "\n")
                      
                      ;; Format comment body (convert Atlassian document format to readable text)
                      (if (and body (alist-get 'content body))
                          (jira--format-comment-content (alist-get 'content body))
                        (insert "No content\n"))
                      (insert "\n\n"))))
              (insert "No comments found.\n")))
        
        ;; Fallback if JSON parsing fails
        (insert "Unable to parse comment data.\n"))
      
      (goto-char (point-min))
      (view-mode 1))
    (switch-to-buffer buffer-name)))
#+end_src

#+begin_src emacs-lisp
(defun jira--format-text-with-marks (text marks)
  "Apply formatting marks to text."
  (when text
    (if (seq-some (lambda (mark) (string= (alist-get 'type mark) "strong")) marks)
        (insert (format "**%s**" text))
      (if (seq-some (lambda (mark) (string= (alist-get 'type mark) "em")) marks)
          (insert (format "*%s*" text))
        (insert text)))))
#+end_src

#+begin_src emacs-lisp
(defun jira--format-inline-content (inline)
  "Format a single inline content element."
  (let ((inline-type (alist-get 'type inline)))
    (cond
     ((string= inline-type "text")
      (let ((text (alist-get 'text inline))
            (marks (alist-get 'marks inline)))
        (jira--format-text-with-marks text marks)))
     
     ((string= inline-type "inlineCard")
      (let ((url (alist-get 'url (alist-get 'attrs inline))))
        (when url
          (insert (format "ðŸ”— %s" url)))))
     
     ((string= inline-type "mention")
      (let* ((attrs (alist-get 'attrs inline))
             (display-name (alist-get 'text attrs))
             (user-id (alist-get 'id attrs)))
        (insert (format "@%s" (or display-name user-id "unknown")))))
     
     (t
      (let ((text (alist-get 'text inline)))
        (when text
          (insert text)))))))
#+end_src

#+begin_src emacs-lisp
(defun jira--format-paragraph (block)
  "Format a paragraph block."
  (let ((block-content (alist-get 'content block)))
    (when block-content
      (dolist (inline block-content)
        (jira--format-inline-content inline))
      (insert "\n"))))
#+end_src

#+begin_src emacs-lisp
(defun jira--format-code-block (block)
  "Format a code block."
  (let* ((block-content (alist-get 'content block))
         (code-text (when block-content
                     (alist-get 'text (car block-content)))))
    (when code-text
      (insert "=\n" code-text "\n=\n"))))
#+end_src

#+begin_src emacs-lisp
(defun jira--format-bullet-list (block)
  "Format a bullet list."
  (let ((items (alist-get 'content block)))
    (dolist (item items)
      (insert "â€¢ ")
      (jira--format-comment-content (alist-get 'content item))
      (insert "\n"))))
#+end_src

#+begin_src emacs-lisp
(defun jira--format-comment-content (content)
  "Format Atlassian document content for readable display."
  (dolist (block content)
    (let ((type (alist-get 'type block)))
      (cond
       ((string= type "paragraph")
        (jira--format-paragraph block))
       
       ((string= type "codeBlock")
        (jira--format-code-block block))
       
       ((string= type "bulletList")
        (jira--format-bullet-list block))
       
       (t
        (let ((text (alist-get 'text block)))
          (when text
            (insert text "\n"))))))))
#+end_src

* Epic Operations

Functions for working with Jira epics - larger work containers that group related issues.

** List Epics

List epics with optional filtering, or list issues in a specific epic.

#+begin_src emacs-lisp
(defun jira-epic-list (&optional epic-key args table-view)
  "List epics or issues in EPIC-KEY.
If EPIC-KEY is provided, lists issues in that epic.
ARGS: optional filtering arguments
TABLE-VIEW: if t, display in table format instead of explorer view"
  (interactive)
  (let ((cmd "jira epic list"))
    (when epic-key (setq cmd (format "%s %s" cmd epic-key)))
    (when table-view (setq cmd (format "%s --table" cmd)))
    (when args (setq cmd (format "%s %s" cmd args)))
    (shell-command-to-string cmd)))
#+end_src

** Create Epic

Create a new epic with the specified parameters.

#+begin_src emacs-lisp
(defun jira-epic-create (epic-name summary &optional priority labels body)
  "Create a new epic.
EPIC-NAME: name of the epic (separate from summary)
SUMMARY: epic summary/title
PRIORITY: epic priority
LABELS: comma-separated labels
BODY: epic description"
  (interactive "sEpic name: \nsSummary: ")
  (let ((cmd (format "jira epic create -n\"%s\" -s\"%s\"" epic-name summary)))
    (when priority (setq cmd (format "%s -y%s" cmd priority)))
    (when labels (setq cmd (format "%s -l%s" cmd labels)))
    (when body (setq cmd (format "%s -b\"%s\"" cmd body)))
    (shell-command cmd)))
#+end_src

** Add Issues to Epic

Add one or more issues to an epic.

#+begin_src emacs-lisp
(defun jira-epic-add (epic-key &rest issue-keys)
  "Add ISSUE-KEYS to EPIC-KEY.
Can add up to 50 issues at once."
  (interactive "sEpic key: ")
  (when (called-interactively-p 'any)
    (let ((issues (read-string "Issue keys (space-separated): ")))
      (setq issue-keys (split-string issues))))
  (let ((cmd (format "jira epic add %s %s" epic-key (string-join issue-keys " "))))
    (shell-command cmd)))
#+end_src

** Remove Issues from Epic

Remove one or more issues from an epic.

#+begin_src emacs-lisp
(defun jira-epic-remove (&rest issue-keys)
  "Remove ISSUE-KEYS from their epic.
Can remove up to 50 issues at once."
  (interactive)
  (when (called-interactively-p 'any)
    (let ((issues (read-string "Issue keys to remove (space-separated): ")))
      (setq issue-keys (split-string issues))))
  (let ((cmd (format "jira epic remove %s" (string-join issue-keys " "))))
    (shell-command cmd)))
#+end_src

* Sprint Operations

Functions for working with agile sprints and sprint planning.

** List Sprints

List sprints or issues in a specific sprint.

#+begin_src emacs-lisp
(defun jira-sprint-list (&optional sprint-id args table-view current prev next state)
  "List sprints or issues in SPRINT-ID.
SPRINT-ID: specific sprint to show issues for
ARGS: additional filtering arguments for issues
TABLE-VIEW: if t, show in table format
CURRENT: if t, show current active sprint
PREV: if t, show previous sprint  
NEXT: if t, show next planned sprint
STATE: comma-separated sprint states (future,active,closed)"
  (interactive)
  (let ((cmd "jira sprint list"))
    (cond
     (current (setq cmd (format "%s --current" cmd)))
     (prev (setq cmd (format "%s --prev" cmd)))
     (next (setq cmd (format "%s --next" cmd)))
     (sprint-id (setq cmd (format "%s %s" cmd sprint-id))))
    (when table-view (setq cmd (format "%s --table" cmd)))
    (when state (setq cmd (format "%s --state %s" cmd state)))
    (when args (setq cmd (format "%s %s" cmd args)))
    (shell-command-to-string cmd)))
#+end_src

** Add Issues to Sprint

Add one or more issues to a sprint.

#+begin_src emacs-lisp
(defun jira-sprint-add (sprint-id &rest issue-keys)
  "Add ISSUE-KEYS to SPRINT-ID.
Can add up to 50 issues at once."
  (interactive "sSprint ID: ")
  (when (called-interactively-p 'any)
    (let ((issues (read-string "Issue keys (space-separated): ")))
      (setq issue-keys (split-string issues))))
  (let ((cmd (format "jira sprint add %s %s" sprint-id (string-join issue-keys " "))))
    (shell-command cmd)))
#+end_src

* Project and Navigation Utilities

Helper functions for project management and quick navigation.

** Get Current User

Get the current authenticated user's account information.

#+begin_src emacs-lisp
(defun jira-me ()
  "Get current user's account name/email."
  (interactive)
  (string-trim (shell-command-to-string "jira me")))
#+end_src

** Open in Browser

Open Jira project or specific issue in the web browser.

#+begin_src emacs-lisp
(defun jira-open (&optional issue-key)
  "Open Jira project or ISSUE-KEY in browser."
  (interactive "sIssue key (optional): ")
  (let ((cmd (if (and issue-key (not (string-empty-p issue-key)))
                 (format "jira open %s" issue-key)
               "jira open")))
    (shell-command cmd)))
#+end_src

** List Projects

List all accessible Jira projects.

#+begin_src emacs-lisp
(defun jira-project-list ()
  "List all accessible Jira projects."
  (interactive)
  (shell-command-to-string "jira project list"))
#+end_src

** List Boards

List all boards in the current project.

#+begin_src emacs-lisp
(defun jira-board-list ()
  "List all boards in the current project."
  (interactive)
  (shell-command-to-string "jira board list"))
#+end_src

** List Releases

List project releases/versions.

#+begin_src emacs-lisp
(defun jira-release-list (&optional project)
  "List releases for PROJECT (or default project if not specified)."
  (interactive)
  (let ((cmd "jira release list"))
    (when project (setq cmd (format "%s --project %s" cmd project)))
    (shell-command-to-string cmd)))
#+end_src

* Search and Discovery

Enhanced search functions that provide interactive interfaces for finding and selecting Jira issues.

** Browse and View Issues

Enhanced function for searching issues with vertico, showing more context in the selection list.

#+begin_src emacs-lisp
(defun jira-browse-issues (&optional query detailed)
  "Browse and view Jira issues with vertico completion.
Searches issues, presents them in vertico for selection, then automatically views the chosen issue.
QUERY can pre-filter the results with jira cli arguments.
DETAILED if t, shows enhanced information including sprint and comment data.
Display format: [TYPE] [ID] [STATUS] [ASSIGNEE] | [TITLE]
Enhanced format: [TYPE] [ID] [STATUS] [SPRINT] [ASSIGNEE] ðŸ’¬N | [TITLE]"
  (interactive)
  (if detailed
      (jira-browse-issues-detailed query)
    (jira-browse-issues-simple query)))

(defun jira-browse-issues-simple (query)
  "Simple browse with basic column information."
  (let* ((columns "--plain --columns type,key,status,assignee,summary --no-headers")
         (raw-output (jira-issue-list (if query 
                                          (format "%s %s" query columns)
                                        columns)))
         (lines (split-string raw-output "\n" t))
         (issues (mapcar (lambda (line)
                          (let ((parts (split-string line "\t" t)))
                            (when (>= (length parts) 5)
                              (let* ((type (or (nth 0 parts) "Unknown"))
                                     (key (or (nth 1 parts) ""))
                                     (status (or (nth 2 parts) "No Status"))
                                     (assignee (or (nth 3 parts) "Unassigned"))
                                     (summary (or (nth 4 parts) "No Summary"))
                                     (display (format "[%s] [%s] [%s] [%s] | %s" 
                                                     type key status assignee summary)))
                                (cons display key)))))
                        lines))
         (filtered-issues (seq-filter #'identity issues)))
    (if filtered-issues
        (let* ((selection (completing-read "Browse issue: " filtered-issues nil t))
               (issue-key (cdr (assoc selection filtered-issues))))
          (when issue-key
            (jira-issue-view issue-key)))
      (message "No issues found"))))

(defun jira-browse-issues-detailed (query)
  "Enhanced browse with sprint information and comment counts."
  (let* ((columns "--plain --columns key --no-headers")
         (raw-output (jira-issue-list (if query 
                                          (format "%s %s" query columns)
                                        columns)))
         (keys (split-string raw-output "\n" t))
         (issues '())
         (total-keys (length keys))
         (processed 0))
    
    ;; Process each issue key to get detailed information
    (message "Loading detailed information for %d issues..." total-keys)
    (dolist (key keys)
      (when (not (string-empty-p (string-trim key)))
        (setq processed (1+ processed))
        (when (= (mod processed 5) 0)  ; Progress indicator every 5 issues
          (message "Loading detailed information... %d/%d" processed total-keys))
        
        (let* ((raw-json (shell-command-to-string (format "jira issue view %s --raw" key)))
               (json-data (ignore-errors (json-parse-string raw-json :object-type 'alist :array-type 'list))))
          (when json-data
            (let* ((fields (alist-get 'fields json-data))
                   (issue-key (alist-get 'key json-data))
                   (summary (alist-get 'summary fields))
                   (status (alist-get 'name (alist-get 'status fields)))
                   (issue-type (alist-get 'name (alist-get 'issuetype fields)))
                   (assignee (alist-get 'displayName (alist-get 'assignee fields)))
                   (comment-total (alist-get 'total (alist-get 'comment fields)))
                   (sprint-data (alist-get 'customfield_10020 fields))
                   (active-sprint (when (and sprint-data (listp sprint-data))
                                   (seq-find (lambda (s) (string= (alist-get 'state s) "active")) sprint-data)))
                   (sprint-name (if active-sprint 
                                   (alist-get 'name active-sprint)
                                 (when (and sprint-data (listp sprint-data)) 
                                   (format "%s(%s)" 
                                          (alist-get 'name (car sprint-data))
                                          (substring (alist-get 'state (car sprint-data)) 0 1)))))
                   (comment-indicator (if (and comment-total (> comment-total 0))
                                         (format " ðŸ’¬%d" comment-total)
                                       ""))
                   (display (format "[%s] [%s] [%s] [%s] [%s]%s | %s" 
                                  (or issue-type "Unknown")
                                  issue-key
                                  (or status "No Status")  
                                  (or sprint-name "No Sprint")
                                  (or assignee "Unassigned")
                                  comment-indicator
                                  (or summary "No Summary"))))
              (push (cons display issue-key) issues))))))
    
    (setq issues (reverse issues))
    (message "Loaded %d issues" (length issues))
    
    (if issues
        (let* ((selection (completing-read "Browse issue (detailed): " issues nil t))
               (issue-key (cdr (assoc selection issues))))
          (when issue-key
            (jira-issue-view issue-key)))
      (message "No issues found"))))
#+end_src

** Interactive Issue Search

Search and select issues with completion-based interface. Returns the selected issue key without viewing.

#+begin_src emacs-lisp
(defun jira-search-issues (&optional query)
  "Interactive search for Jira issues with completion.
Returns the selected issue key. QUERY can pre-filter the results."
  (interactive)
  (let* ((raw-output (jira-issue-list (or query "--plain --columns key,summary --no-headers")))
         (lines (split-string raw-output "\n" t))
         (issues (mapcar (lambda (line)
                          (let ((parts (split-string line "\t" t)))
                            (when (>= (length parts) 2)
                              (cons (format "%s: %s" (car parts) (cadr parts))
                                    (car parts)))))
                        lines))
         (filtered-issues (seq-filter #'identity issues)))
    (if filtered-issues
        (let ((selection (completing-read "Select issue: " filtered-issues nil t)))
          (cdr (assoc selection filtered-issues)))
      (message "No issues found")
      nil)))
#+end_src

** Advanced Search with Filters

Comprehensive search function with vertico completion for common options.

#+begin_src emacs-lisp
(defun jira-search-issues-advanced ()
  "Advanced interactive search with vertico completion for common options."
  (interactive)
  (let* (;; Get recent assignees and reporters from actual issues
         (recent-issues (jira-issue-list "--plain --columns assignee,reporter --no-headers"))
         (issue-lines (split-string recent-issues "\n" t))
         
         ;; Extract unique assignees and reporters from recent issues
         ;; Note: jira CLI includes issue key as first column even when not requested
         (recent-assignees (delete-dups
                           (mapcar (lambda (line)
                                    (let ((parts (split-string line "\t" t)))
                                      (when (>= (length parts) 2)
                                        (string-trim (nth 1 parts))))) ; Assignee is 2nd column
                                  issue-lines)))
         (recent-reporters (delete-dups
                           (mapcar (lambda (line)
                                    (let ((parts (split-string line "\t" t)))
                                      (when (>= (length parts) 3)
                                        (string-trim (nth 2 parts))))) ; Reporter is 3rd column
                                  issue-lines)))
         
         ;; Use actual Bitwarden Jira statuses and priorities
         (status-options '("" "Abandoned" "Blocked" "Code Review" "Done" "In Analysis" 
                          "In Progress" "Needs Triage" "Product Review" "Ready for QA" 
                          "Reproduced" "To Do" "Triaged"))
         (priority-options '("" "Blocker" "High" "Medium" "Low"))
         (time-options '("" "today" "week" "month" "year" "-1d" "-3d" "-7d" "-14d" "-30d"))
         (assignee-options (delete-dups (append '("" "me" "x") 
                                               (seq-filter (lambda (x) (and x (not (string-empty-p x)))) 
                                                          recent-assignees))))
         (reporter-options (delete-dups (append '("" "me") 
                                               (seq-filter (lambda (x) (and x (not (string-empty-p x)))) 
                                                          recent-reporters))))
         
         ;; Interactive selections with vertico (allowing free-form input)
         (assignee (completing-read "Assignee (empty=all, me=self, x=unassigned, or type name): " 
                                   assignee-options nil nil))
         (status (completing-read "Status (empty=all, or type custom): " 
                                 status-options nil nil))
         (priority (completing-read "Priority (empty=all): " 
                                   priority-options nil nil))
         (created (completing-read "Created (empty=all): " 
                                  time-options nil nil))
         (labels (read-string "Labels (comma-separated, empty=all): "))
         (reporter (completing-read "Reporter (empty=all, me=self, or type name): " 
                                   reporter-options nil nil))
         (args '()))
    
    ;; Build filter arguments
    (when (not (string-empty-p assignee))
      (cond
       ((string= assignee "me") (push (format "-a%s" (jira-me)) args))
       ((string= assignee "x") (push "-ax" args))
       (t (push (format "-a\"%s\"" assignee) args))))
    
    (when (not (string-empty-p status))
      (push (format "-s\"%s\"" status) args))
    
    (when (not (string-empty-p priority))
      (push (format "-y%s" priority) args))
    
    (when (not (string-empty-p created))
      (cond
       ((member created '("today" "week" "month" "year"))
        (push (format "--created %s" created) args))
       ((string-match "^-[0-9]+[dwmy]$" created)
        (push (format "--created %s" created) args))
       (t (push (format "--created \"%s\"" created) args))))
    
    (when (not (string-empty-p labels))
      (dolist (label (split-string labels "," t))
        (push (format "-l%s" (string-trim label)) args)))
    
    (when (not (string-empty-p reporter))
      (if (string= reporter "me")
          (push (format "-r%s" (jira-me)) args)
        (push (format "-r\"%s\"" reporter) args)))
    
    ;; Execute search
    (let ((query (string-join (reverse args) " ")))
      (if args
          (jira-browse-issues query)
        (jira-browse-issues)))))
#+end_src

** Enhanced Browse Toggle

Toggle between simple and detailed browse modes.

#+begin_src emacs-lisp
(defun jira-browse-issues-enhanced (&optional query)
  "Browse and view Jira issues with detailed information (sprint, comments).
This version shows more context but takes longer to load."
  (interactive)
  (jira-browse-issues query t))
#+end_src

** Quick Search Helpers

Convenient shortcuts for common search patterns with enhanced display options.

#+begin_src emacs-lisp
(defun jira-search-my-issues (&optional detailed)
  "Browse and view issues assigned to me.
With prefix argument, show detailed information including sprint and comments."
  (interactive "P")
  (jira-browse-issues (format "-a%s" (jira-me)) detailed))

(defun jira-search-recent-issues (&optional detailed)
  "Browse and view issues created this week.
With prefix argument, show detailed information including sprint and comments."
  (interactive "P")
  (jira-browse-issues "--created week" detailed))

(defun jira-search-high-priority (&optional detailed)
  "Browse and view high priority issues.
With prefix argument, show detailed information including sprint and comments."
  (interactive "P")
  (jira-browse-issues "-yHigh" detailed))

(defun jira-search-unassigned (&optional detailed)
  "Browse and view unassigned issues.
With prefix argument, show detailed information including sprint and comments."
  (interactive "P")
  (jira-browse-issues "-ax" detailed))
#+end_src

** Custom Field Utilities

Helper functions for working with project-specific custom fields.

#+begin_src emacs-lisp
(defun jira-show-custom-fields (issue-key)
  "Show all custom fields for ISSUE-KEY in a dedicated buffer."
  (interactive "sIssue key: ")
  (let* ((buffer-name (format "*Jira Custom Fields: %s*" issue-key))
         (raw-json (shell-command-to-string (format "jira issue view %s --raw" issue-key)))
         (json-data (ignore-errors (json-parse-string raw-json :object-type 'alist :array-type 'list))))
    
    (with-current-buffer (get-buffer-create buffer-name)
      (when (bound-and-true-p view-mode)
        (view-mode -1))
      (erase-buffer)
      
      (if json-data
          (let* ((fields (alist-get 'fields json-data))
                 (summary (alist-get 'summary fields)))
            
            ;; Header
            (insert (format "ðŸ”§ Custom Fields for %s: %s\n" issue-key summary))
            (insert (make-string (+ 20 (length issue-key) (length summary)) ?=) "\n\n")
            
            ;; Filter and display custom fields
            (dolist (field fields)
              (let ((field-name (car field))
                    (field-value (cdr field)))
                (when (and (string-prefix-p "customfield_" (symbol-name field-name))
                          field-value
                          (not (equal field-value 'null)))
                  (insert (format "%s: " (symbol-name field-name)))
                  
                  ;; Format different types of field values
                  (cond
                   ;; Sprint data (customfield_10020)
                   ((and (eq field-name 'customfield_10020) (listp field-value))
                    (insert "\n")
                    (dolist (sprint field-value)
                      (insert (format "  â€¢ %s (%s)\n"
                                    (alist-get 'name sprint)
                                    (alist-get 'state sprint)))))
                   
                   ;; JSON objects
                   ((and (listp field-value) (not (stringp field-value)))
                    (insert (format "%s\n" (json-serialize field-value))))
                   
                   ;; Simple values  
                   (t
                    (insert (format "%s\n" field-value))))
                  
                  (insert "\n")))))
        
        ;; Fallback if JSON parsing fails
        (insert "Unable to parse custom field data.\n"))
      
      (goto-char (point-min))
      (view-mode 1))
    (switch-to-buffer buffer-name)))
#+end_src
