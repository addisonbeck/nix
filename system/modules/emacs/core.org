#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle core.el :results none

* TODOs
** TODO Set up more robust task logging

** TODO Set up some default folding behavior

** TODO Set up org clock
* Basic Settings
#+begin_src emacs-lisp
  ;; Disable backup files and configure indentation
  (setq make-backup-files nil)
  (setq-default indent-tabs-mode nil)
  (electric-indent-mode 1)
  (setq-default tab-width 2
		indent-tabs-mode nil
		tab-stop-list (number-sequence 2 120 2))
  (setq confirm-kill-emacs nil)
  (setq auto-save-default nil
	create-lockfiles nil)
  (setq select-enable-clipboard t)
  (setq case-fold-search t)
  (xterm-mouse-mode 1)
  (setq-default fill-column 77)
  (global-hl-line-mode -1)
  (setq sentence-end-double-space nil)
#+end_src

* Kill Other Buffers
#+begin_src emacs-lisp
  (defun kill-other-buffers ()
    "Kill all buffers except the current one."
    (interactive)
    (mapc 'kill-buffer
	  (delq (current-buffer)
		(buffer-list))))
#+end_src

* Package Management
#+begin_src emacs-lisp
  (require 'package)

  ;; Use Package Configuration
  (use-package nerd-icons)

  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (when (daemonp)
    (exec-path-from-shell-initialize))
#+end_src

* Dashboard Configuration
#+begin_src emacs-lisp
  (defun my/extract-quotes-from-org-files ()
    "Extract headlines tagged with :quote: from org files in notes directory."
    (let ((quotes '())
	  (notes-dir "~/notes"))
      (dolist (file (directory-files-recursively notes-dir "\\.org$"))
	(with-temp-buffer
	  (insert-file-contents file)
	  (org-mode)
	  (goto-char (point-min))
	  (while (re-search-forward "^\\*+\\s-+\\(.*?\\)\\s-+:quote:" nil t)
	    (let* ((headline (match-string-no-properties 1))
		   (element (org-element-at-point))
		   (content (org-element-property :contents-begin element))
		   (end (org-element-property :contents-end element))
		   (raw-text (when (and content end)
			       (string-trim (buffer-substring-no-properties content end))))
		   (quote-text
		    (when raw-text
		      ;; Process text to handle quote blocks
		      (with-temp-buffer
			(insert raw-text)
			;; Replace #+begin_quote and #+end_quote with empty strings
			(goto-char (point-min))
			(while (re-search-forward "^[ \t]*#\\+begin_quote[ \t]*$" nil t)
			  (replace-match ""))
			(goto-char (point-min))
			(while (re-search-forward "^[ \t]*#\\+end_quote[ \t]*$" nil t)
			  (replace-match ""))
			;; Return the cleaned text
			(string-trim (buffer-string))))))
	      (when (and headline (not (string-empty-p headline))
			 quote-text (not (string-empty-p quote-text)))
		(push (format "%s\n\nâ€” %s" quote-text headline) quotes))))))
      (or quotes
	  ;; Fallback quotes if none found
	  '("Emacs is the extensible self-documenting editor.\n\nâ€” GNU Emacs"
	    "The journey of a thousand miles begins with one step.\n\nâ€” Lao Tzu"))))

  (use-package dashboard
    :ensure t
    :init
    (setq dashboard-icon-type 'nerd-icons)
    (setq dashboard-projects-backend 'projectile)
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-center-content t
	  dashboard-items '((recents . 5)
			    (projects . 5)
			    (bookmarks . 5))
	  dashboard-set-heading-icons t
	  dashboard-set-file-icons t
	  dashboard-show-shortcuts t
	  dashboard-set-footer t
	  dashboard-footer-messages (my/extract-quotes-from-org-files))
    (setq dashboard-heading-icons '((recents   . "nf-oct-history")
				    (bookmarks . "nf-oct-bookmark")
				    (projects  . "nf-oct-project"))))
#+end_src

* Evil Mode Configuration
#+begin_src emacs-lisp
  ;; Test
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)

  (use-package evil
    :ensure t
    :config
    (evil-mode 1)

    ;; Custom movement functions
    (defun evil-move-half-page-down ()
      "Move cursor half page down"
      (interactive)
      (evil-next-line (/ (window-height) 4))
      (evil-scroll-line-to-center nil))

    (defun evil-move-half-page-up ()
      "Move cursor half page up"
      (interactive)
      (evil-previous-line (/ (window-height) 4))
      (evil-scroll-line-to-center nil))

    ;; Bind J and K to half-page movement
    (define-key evil-normal-state-map (kbd "J") 'evil-move-half-page-down)
    (define-key evil-normal-state-map (kbd "K") 'evil-move-half-page-up))

  (use-package evil-collection
    :ensure t
    :after evil
    :config
    (evil-collection-init))

  ;; Configure evil-collection for magit
  (with-eval-after-load 'evil-collection-magit
    (evil-collection-define-key 'normal 'magit-status-mode-map
				"V" #'magit-start-region-select))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  (evil-define-key 'motion org-agenda-mode-map
		   (kbd "C-p") 'projectile-switch-project
		   (kbd "C-f") 'projectile-find-file
		   (kbd "<left>") 'org-agenda-earlier
		   (kbd "<right>") 'org-agenda-later
		   (kbd "gx")  'org-agenda-open-link
		   (kbd "t") 'org-agenda-todo
		   (kbd "T") 'org-agenda-todo-yesterday)
#+end_src

* Cycle Line Number Function
#+begin_src emacs-lisp
  (defun cycle-line-numbers ()
    "Cycle through line number modes: off -> relative -> normal -> off."
    (interactive)
    (cond
     ;; If currently off, switch to relative
     ((not display-line-numbers)
      (setq display-line-numbers 'relative)
      (message "Line numbers: RELATIVE"))

     ;; If currently relative, switch to normal
     ((eq display-line-numbers 'relative)
      (setq display-line-numbers t)
      (message "Line numbers: NORMAL"))

     ;; If currently normal, switch to off
     (t
      (setq display-line-numbers nil)
      (message "Line numbers: OFF"))))

  ;; Bind to "N" in evil normal mode
  (with-eval-after-load 'evil
    (evil-define-key 'normal 'global "N" 'cycle-line-numbers))
#+end_src
* Server Configuration
#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+end_src

* Project Management
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (define-key projectile-command-map (kbd "d") 'projectile-find-file-in-directory)
    (define-key projectile-command-map (kbd "P") 'my/projectile-find-file-in-all-projects)
    (setq projectile-indexing-method 'alien)
    (setq projectile-git-command "git ls-files -zco -X ~/.gitignore")
    (setq projectile-known-projects
	  (mapcar (lambda (project)
		    (expand-file-name (my/get-project-path (car project))))
		  my/projects))
    (setq projectile-auto-discover nil)
    (projectile-save-known-projects))
#+end_src

* Consult
#+begin_src emacs-lisp
  (require 'consult)
#+end_src
* Completion Framework
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles . (partial-completion))))))

  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))

  ;; Custom find-from-here function
  (defun find-from-here ()
    "Find files from current buffer's directory."
    (interactive)
    (when buffer-file-name
      (consult-find (file-name-directory buffer-file-name))))
#+end_src

* Tree-sitter Configuration
#+begin_src emacs-lisp
  (use-package treesit-auto
    :config
    (global-treesit-auto-mode)
    (setq treesit-auto-install 'prompt)
    (setq treesit-auto-langs '(typescript javascript tsx jsx yaml)))

  (use-package typescript-ts-mode
    :ensure t
    :mode (("\\.ts\\'" . typescript-ts-mode)
	   ("\\.tsx\\'" . tsx-ts-mode))
    :init
    (add-to-list 'major-mode-remap-alist '(typescript-mode . typescript-ts-mode))
    (add-to-list 'major-mode-remap-alist '(tsx-mode . tsx-ts-mode)))

  ;; Note: Tree-sitter grammars are provided by Nix configuration
#+end_src

* LSP Configuration
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :hook ((typescript-ts-mode . lsp)
	   (tsx-ts-mode . lsp)
	   (typescript-mode . lsp)
	   (csharp-mode . lsp)
	   (rust-mode . lsp)
	   (nix-mode . lsp)
	   (json-mode . lsp)
	   (sql-mode . lsp)
	   (lua-mode . lsp))
    :commands lsp
    :config
    ;;(setq lsp-nix-nixd-server-path "nixd")
    ;;(setq lsp-enabled-clients '(nixd-lsp))
    (setq lsp-auto-guess-root t)
    (setq lsp-enable-symbol-highlighting t)
    (setq lsp-enable-on-type-formatting t)
    (setq lsp-modeline-code-actions-enable t)
    (setq lsp-modeline-diagnostics-enable t)
    (setq lsp-diagnostics-provider :flycheck)
    (setq lsp-ui-doc-enable t)
    (setq lsp-ui-doc-show-with-cursor t)
    (add-to-list 'lsp-disabled-clients 'copilot-ls)
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\chats\\'")
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-headerline-breadcrumb-mode nil)
    (lsp-enable-which-key-integration t))

  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode)

  ;; Company mode for completions
  (use-package company
    :ensure t
    :config
    (setq company-minimum-prefix-length 1
	  company-idle-delay 0.0))

  ;; Add flycheck configuration
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode))
#+end_src

* Magit and Forge Configuration
#+begin_src emacs-lisp
  (defun magit-status-project ()
    "Switch project and open magit."
    (interactive)
    (let ((projectile-switch-project-action 'magit-status))
      (projectile-switch-project)))

  (use-package forge
    :ensure t
    :after magit
    :config
    ;; Configure GitHub authentication
    (setq auth-sources '("~/.authinfo"))
    ;; Optionally set the number of items to fetch
    (setq forge-topic-list-limit '(60 . 0)))
#+end_src

* Basic Settings and Markdown Configuration
#+begin_src emacs-lisp
;; Basic settings
(setq notes-directory "~/notes")
(setq markdown-command "pandoc")

;; Markdown configuration
(use-package markdown-mode
  :ensure t
  :mode (("\\.md\\'" . markdown-mode)
   ("\\.markdown\\'" . markdown-mode)))

(defun org-region-to-markdown (start end)
  "Convert the selected region from Org to Markdown using pandoc."
  (interactive "r")
  (shell-command-on-region start end "pandoc -f org -t markdown" "*Pandoc Output*" t))
#+end_src

* Org Mode Configuration
** Requried Packages

#+begin_src emacs-lisp
  (require 'transient)
#+end_src

** Basic Org Settings

*** Directory Configuration
Sets the main directory for Org files, stored in iCloud for sync across devices.

#+begin_src emacs-lisp
(defcustom my-notes-directory "/Users/me/Library/Mobile Documents/com~apple~CloudDocs/notes/"
  "Path to my notes directory."
  :type 'directory
  :group 'org)
(defcustom my-agenda-directory (expand-file-name "agenda" my-notes-directory)
  "Path to my agenda directory, located in the notes directory."
  :type 'directory
  :group 'org)
(defcustom my-nix-systems-flake-directory "/Users/me/nix"
  "Path to my nix directory."
  :type 'directory
  :group 'org)
(setq org-directory my-notes-directory)
#+end_src

*** Display Settings
Disables line truncation for better readability of long lines in org files.

#+begin_src emacs-lisp
  (setq org-startup-truncated nil)
#+end_src

*** Task Logging

#+begin_src help
org-log-done is a variable defined in â€˜org.elâ€™.

Its value is â€˜timeâ€™
Original value was nil

Information to record when a task moves to the DONE state.

Possible values are:

nil     Donâ€™t add anything, just change the keyword
time    Add a time stamp to the task
note    Prompt for a note and add it with template â€˜org-log-note-headingsâ€™

This option can also be set with on a per-file-basis with

   #+STARTUP: nologdone
   #+STARTUP: logdone
   #+STARTUP: lognotedone

You can have local logging settings for a subtree by setting the LOGGING
property to one or more of these keywords.
#+end_src

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

*** Logging Drawer

Places logged state changes and notes into a properties drawer to keep entries clean.

#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

*** Default Folding
Sets the initial visibility state to overview when opening org files.

#+begin_src help
org-startup-folded is a variable defined in â€˜org.elâ€™.

Its value is â€˜overviewâ€™
Original value was â€˜showeverythingâ€™

Initial folding state of headings when entering Org mode.

Allowed values are:

symbol â€˜nofoldâ€™
  Do not fold headings.

symbol â€˜foldâ€™
  Fold everything, leaving only top-level headings visible.

symbol â€˜contentâ€™
  Leave all the headings and sub-headings visible, but hide their
  text.  This is an equivalent of table of contents.

symbol â€˜show2levelsâ€™, â€˜show3levelsâ€™, â€˜show4levelsâ€™, â€˜show5levelsâ€™
  Show headings up to Nth level.

symbol â€˜showeverythingâ€™ (default)
  Start Org mode in fully unfolded state.  Unlike all other allowed
  values, this value prevents drawers, blocks, and archived subtrees
  from being folded even when â€˜org-cycle-hide-block-startupâ€™,
  â€˜org-cycle-open-archived-treesâ€™, or â€˜org-cycle-hide-drawer-startupâ€™
  are non-nil.  Per-subtree visibility settings (see manual node
  â€˜(org)Initial visibility)â€™) are also ignored.

This can also be configured on a per-file basis by adding one of
the following lines anywhere in the buffer:

   #+STARTUP: fold              (or â€˜overviewâ€™, this is equivalent)
   #+STARTUP: nofold            (or â€˜showallâ€™, this is equivalent)
   #+STARTUP: content
   #+STARTUP: show<n>levels (<n> = 2..5)
   #+STARTUP: showeverything

Set â€˜org-agenda-inhibit-startupâ€™ to a non-nil value if you want
to ignore this option when Org opens agenda files for the first
time.
#+end_src

#+begin_src emacs-lisp
  (setq org-startup-folded 'fold)
#+end_src

*** Tag Display
Prevents automatic alignment of tags, for functional preference 

#+begin_src emacs-lisp
  (setq org-auto-align-tags nil)
#+end_src

*** Export Configuration
Specifies which export backends are loaded by default.

#+begin_src emacs-lisp
  (setq org-export-backends '(html icalendar latex man md org json))
#+end_src

*** Image Display Size

#+begin_src help
org-image-max-width is a variable defined in â€˜org.elâ€™.

Its value is â€˜windowâ€™
Original value was â€˜fill-columnâ€™

When non-nil, limit the displayed image width.
This setting only takes effect when â€˜org-image-actual-widthâ€™ is set to
t or when #+ATTR* is set to t.

Possible values:
- â€˜fill-columnâ€™ :: limit width to â€˜fill-columnâ€™
- â€˜windowâ€™      :: limit width to window width
- integer       :: limit width to number in pixels
- float         :: limit width to that fraction of window width
- nil             :: do not limit image width

  This variable was introduced, or its default value was changed, in
  version 9.7 of the Org package that is part of Emacs 30.1.
  You can customize this variable.
#+end_src

#+begin_src emacs-lisp
  (setq org-image-max-width 120)
#+end_src

*** Inline Images
Automatically displays inline images when opening org files.

I noticed that this started creating weird deadlock errors on my images and so I've turned it off

#+begin_src emacs-lisp :tangle no
  (setq org-startup-with-inline-images t)
#+end_src

*** Inline Images Cycling
Toggles display of inline images when cycling visibility.

#+begin_src emacs-lisp
  (setq org-cycle-inline-images-display t)
#+end_src

*** Remote Images
Automatically downloads and displays remote images.

#+begin_src emacs-lisp
  (setq org-display-remote-inline-images 'download)
#+end_src

*** <CR> Behavior On Org Links

Makes the Enter key follow links on org fils

#+begin_src emacs-lisp
  (setq org-return-follows-link t)
#+end_src

** "TODO" Keyword Behavior
*** Restrict Closing Unfinished Parent 

Prevents me from changing a TODO to DONE if it has unresolved children or checklist items

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

*** Hide "DONE" Items On The Agenda

Don't show DONE items in the agenda

#+begin_src emacs-lisp
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-timestamp-if-done t)
#+end_src

** Font Configuration
#+begin_src emacs-lisp
  ;; Define your custom face settings in a function
  (defun my/apply-custom-faces ()
    "Apply all my custom face settings."
    ;; Basic font settings
    (set-face-attribute 'default nil :family "Iosevka" :height 140)
    (set-face-attribute 'variable-pitch nil :family "Iosevka Etoile" :height 140)
    (set-face-attribute 'fixed-pitch nil :family "Iosevka" :height 140)

    ;; Org faces
    (with-eval-after-load 'org
      (custom-set-faces
       '(org-document-info-keyword ((t (:inherit variable-pitch :height 1.0))))
       '(org-document-title ((t (:inherit variable-pitch :height 1.3))))
       '(org-level-1 ((t (:inherit variable-pitch :height 1.3))))
       '(org-level-2 ((t (:inherit variable-pitch :height 1.2))))
       '(org-level-3 ((t (:inherit variable-pitch :height 1.1))))
       '(org-level-4 ((t (:inherit variable-pitch :height 1.0))))
       '(org-level-5 ((t (:inherit variable-pitch :height 1.0))))
       '(org-level-6 ((t (:inherit variable-pitch :height 1.0))))
       '(org-level-7 ((t (:inherit variable-pitch :height 1.0))))
       '(org-level-8 ((t (:inherit variable-pitch :height 1.0))))
       '(org-agenda-date-today ((t (:inherit variable-pitch :height 1.3))))
       '(org-super-agenda-header ((t (:inherit variable-pitch :height 1.2))))

       ;; Keep these elements as fixed-pitch even in variable-pitch-mode
       '(org-block ((t (:inherit fixed-pitch))))
       '(org-code ((t (:inherit fixed-pitch))))
       '(org-table ((t (:inherit fixed-pitch))))
       '(org-verbatim ((t (:inherit fixed-pitch))))
       '(org-special-keyword ((t (:inherit fixed-pitch :height 140))))
       '(org-drawer ((t (:inherit fixed-pitch :height 140))))
       '(org-property-value ((t (:inherit fixed-pitch :height 140))))
       '(org-modern-label ((t (:inherit fixed-pitch :height 140))))
       '(org-modern-statistics ((t (:inherit fixed-pitch :height 140))))
       '(org-modern-tag ((t (:inherit fixed-pitch :height 140)))))))

  ;; Apply custom faces when Emacs starts
  (add-hook 'after-init-hook 'my/apply-custom-faces)

  (setq org-modern-hide-stars nil)
  (setq org-modern-star nil)

  (add-hook 'markdown-mode-hook (lambda ()
				  (breadcrumb-local-mode 1)
				  (variable-pitch-mode 1)
				  (set-face-attribute 'markdown-code-face nil :inherit 'fixed-pitch)
				  (set-face-attribute 'markdown-pre-face nil :inherit 'fixed-pitch)))

  (add-hook 'prog-mode (lambda ()
			 (breadcrumb-local-mode 1)
			 (variable-pitch-mode 1)
			 (set-face-attribute 'markdown-code-face nil :inherit 'fixed-pitch)
			 (set-face-attribute 'markdown-pre-face nil :inherit 'fixed-pitch)))
#+end_src

** Org Babel and Source Blocks
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp :tangle no . t)
     (shell . t)
     (org . t)
     (mermaid . t)
     ))

  (setq org-babel-sh-command "bash -l -c")

  (setenv "PUPPETEER_EXECUTABLE_PATH" 
	  (or (executable-find "google-chrome-stable")
	      (executable-find "google-chrome")))

  (setq org-src-preserve-indentation nil
	org-edit-src-content-indentation 0)

  (require 'ox-json)

  (use-package ob-mermaid
    :config
    ;; Set the path to the mermaid CLI using the custom puppeteer-cli
    (setq ob-mermaid-cli-path (executable-find "mmdc"))
    ;; If you need to specify the Chrome executable directly:
    (setq ob-mermaid-browser-path (executable-find "google-chrome-stable")))

  ;; Enable automatic display of inline images after executing babel blocks
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
  (setq org-redisplay-inline-images t)

  ;; Allow evaluation of code blocks without confirmation for safe languages
  (defun my/org-confirm-babel-evaluate (lang body)
    (not (member lang '("emacs-lisp :tangle no" "shell"))))
  ;;(setq org-confirm-babel-evaluate 'my/org-confirm-babel-evaluate)
  (setq org-confirm-babel-evaluate nil)

  ;; Ensure pretty fontification of source blocks
  (setq org-src-fontify-natively t)

  ;;(require 'ob-async) ;; Allow for asyncround running of babel blocks

  (require 'org-make-toc)
#+end_src

** Keybindings and Navigation
#+begin_src emacs-lisp
  (define-key org-mode-map (kbd "RET") 'newline)

  ;; These bindings just emulate the defaults instead of doing a bunch of weird org specific stuff.
  (evil-define-key 'insert org-mode-map (kbd "RET") 'newline)
  (evil-define-key 'insert org-mode-map (kbd "<tab>") 'tab-to-tab-stop)
  (defun my-org-evil-open-below ()
    "Open line below preserving org structure but preventing reformatting."
    (interactive)
    ;; Use evil's basic open behavior
    (evil-open-below 1)
    ;; Exit insert state then re-enter to avoid auto-formatting
    (evil-normal-state)
    (evil-insert-state))

  (evil-define-key 'normal org-mode-map "o" 'my-org-evil-open-below)
#+end_src

** Org Agenda Files Management
#+begin_src emacs-lisp
(defun my/get-org-agenda-files ()
  "Return a minimal, fixed set of agenda files for performance."
  (list (expand-file-name "logs.org" my-notes-directory)
        (expand-file-name "budget.org" my-notes-directory)
        (expand-file-name "inbox.org" my-notes-directory)
        (expand-file-name "inbox-mobile.org" my-notes-directory)
        (expand-file-name "reminders.org" my-agenda-directory)
        (expand-file-name "meal-plan.org" my-agenda-directory)
        (expand-file-name "contacts.org" my-notes-directory)
        (expand-file-name "code-reviews.org" my-notes-directory)))

(defun my/set-org-agenda-files ()
  "Set org-agenda-files to a minimal, fixed set."
  (interactive)
  (setq org-agenda-files (my/get-org-agenda-files)))

(add-hook 'after-init-hook #'my/set-org-agenda-files)
(add-hook 'org-agenda-mode-hook #'my/set-org-agenda-files)
#+end_src

** Org Refile

*** Targets

#+begin_src emacs-lisp
  (setq org-refile-targets '((org-agenda-files :maxlevel . 2)))
#+end_src

** Org To Jira
#+begin_src emacs-lisp :tangle no
  (use-package ox-jira
    :ensure t
    :after org)
#+end_src
** Org Capture Templates
#+begin_src emacs-lisp 
  (setq org-directory "/Users/me/Library/Mobile Documents/com~apple~CloudDocs/notes/")
  (setq org-default-notes-file (expand-file-name "inbox.org" my-notes-directory))
  (setq org-capture-templates
	'(
	  ("l" "Log" entry
	   (file org-default-notes-file)
	   "* %U \n%?")
	  ("e" "Event" entry
	   (file org-default-notes-file)
	   "* %^{Title}\n%^T\n%?")
	  ("t" "Todo" entry
	   (file org-default-notes-file)
	   "* TODO %^{Title}\nDEADLINE: %t\n%?")
	  ("a" "A link to the current location in the current file" entry
	   (file org-default-notes-file)
	   "* %a")
	  ("s" "Source block" entry
	   (file org-default-notes-file)
	   "* %^{Title}\n#+begin_src org\n%?\n#+end_src" :immediate-finish nil :jump-to-captured t)
	  ))

  (defgroup my/budget nil
    "My budget capture settings."
    :group 'org-capture)

  (defcustom my/budget-file "~/notes/budget.org"
    "Org file containing my budget."
    :type 'file
    :group 'my/budget)

  (defcustom my/budget-payees-heading "Payees"
    "Heading name under which payees are listed in the org file."
    :type 'string
    :group 'my/budget)

  (defcustom my/budget-accounts-heading "Accounts"
    "Heading name under which accounts are listed in the org file."
    :type 'string
    :group 'my/budget)

  (defcustom my/budget-categories-heading "Categories"
    "Heading name under which categories are listed in the org file."
    :type 'string
    :group 'my/budget)

  (defun my/load-budget-items-from-org (heading-name)
    "Load items from subheadings under the specified HEADING-NAME."
    (when (file-exists-p my/budget-file)
      (with-temp-buffer
	(insert-file-contents my/budget-file)
	(org-mode)
	(let (items)
	  ;; Find the specified heading
	  (goto-char (point-min))
	  (when (re-search-forward (format "^\\*+\\s-+%s" (regexp-quote heading-name)) nil t)
	    (let ((parent-level (org-outline-level)))
	      (org-map-entries
	       (lambda ()
		 (when (= (org-outline-level) (1+ parent-level))
		   ;; This is a direct child of our heading
		   (push (org-get-heading t t t t) items)))
	       nil 'tree)))
	  (nreverse items)))))

  (defun my/load-budget-payees-from-org ()
    "Load payees from subheadings under the Payees heading."
    (my/load-budget-items-from-org my/budget-payees-heading))

  (defun my/load-budget-accounts-from-org ()
    "Load accounts from subheadings under the Accounts heading."
    (my/load-budget-items-from-org my/budget-accounts-heading))

  (defun my/load-budget-categories-from-org ()
    "Load categories from subheadings under the Categories heading."
    (my/load-budget-items-from-org my/budget-categories-heading))

  (defcustom my/budget-payees (my/load-budget-payees-from-org)
    "List of payees for budget capture."
    :type '(repeat string)
    :group 'my/budget)

  (defcustom my/budget-accounts (my/load-budget-accounts-from-org)
    "List of accounts for budget capture."
    :type '(repeat string)
    :group 'my/budget)

  (defcustom my/budget-categories (my/load-budget-categories-from-org)
    "List of categories for budget capture."
    :type '(repeat string)
    :group 'my/budget)

  (defun my/budget--capture-template ()
    "Return an org-capture template string for a budget transaction."
    ;; Refresh lists from org file
    (setq my/budget-payees (my/load-budget-payees-from-org))
    (setq my/budget-accounts (my/load-budget-accounts-from-org))
    (setq my/budget-categories (my/load-budget-categories-from-org))

    (let* ((date     (org-read-date nil nil nil "Date: "))
	   (amount   (read-string "Amount: "))
	   (payee    (completing-read "Payee: " my/budget-payees))
	   (account  (completing-read "Account: " my/budget-accounts))
	   (category (completing-read "Category: " my/budget-categories)))
      (concat
       "** [PENDING] [" date "]: $" amount " @ " payee " on " account "\n"
       "%^{Description}\n"
       "#+begin_src ledger\n"
       date " ! " payee "\n"
       "    " category "  $" amount "\n"
       "    " account "\n"
       "#+end_src\n")))

  (add-to-list 'org-capture-templates `("b" "Budgeting templates"))

  (add-to-list 'org-capture-templates
	       `("bt" "Budget transaction" entry
		 (file org-default-notes-file)
		 (function my/budget--capture-template)
		 :empty-lines 1))

  (defun my/budget--capture-new-payee ()
    "Return an org-capture template string for a new budget payee."
    (let* ((payee (read-string "New Payee Name: ")))
      (format "* %s%%?" payee)))

  (add-to-list 'org-capture-templates
	       `("bp" "Budget payee" entry
		 (file+headline ,my/budget-file ,my/budget-payees-heading)
		 (function my/budget--capture-new-payee)
		 :empty-lines 0))

  (defun my/budget--capture-new-account ()
    "Return an org-capture template string for a new budget account."
    (let* ((account (read-string "New Account Name: ")))
      (format "* %s%%?" account)))

  (add-to-list 'org-capture-templates
	       `("ba" "Budget account" entry
		 (file+headline ,my/budget-file ,my/budget-accounts-heading)
		 (function my/budget--capture-new-account)
		 :empty-lines 0))

  (defun my/budget--capture-new-category ()
    "Return an org-capture template string for a new budget category."
    (let* ((category (read-string "New Category Name: ")))
      (format "* %s\n%%?" category)))

  (add-to-list 'org-capture-templates
	       `("bc" "Budget category" entry
		 (file+headline ,my/budget-file ,my/budget-categories-heading)
		 (function my/budget--capture-new-category)
		 :empty-lines 0))
#+end_src

#+begin_src emacs-lisp :tangle no
(defun finalize-transaction-under-cursor ()
  "Finalizes a pending transaction by:
   1. Removing '[PENDING]' from the heading
   2. Converting '!' to '*' in the ledger transaction"
  (interactive)
  (save-excursion
    ;; Find the heading containing the transaction
    (while (and (not (org-at-heading-p)) 
                (not (bobp)))
      (org-backward-heading-same-level 1 t))
    
    ;; Remove [PENDING] from the heading
    (when (org-at-heading-p)
      (let ((case-fold-search nil))
        (beginning-of-line)
        (when (re-search-forward "\\(\\*+\\s-+\\)\\(\\[PENDING\\]\\s-+\\)" (line-end-position) t)
          (replace-match "\\1"))))
    
    ;; Find the ledger source block
    (let ((end-of-section (save-excursion
                            (or (org-get-next-sibling)
                                (point-max)))))
      (forward-line)
      (while (and (< (point) end-of-section)
                  (not (looking-at "^#\\+begin_src ledger")))
        (forward-line))
      
      ;; If we found a ledger block, change ! to *
      (when (looking-at "^#\\+begin_src ledger")
        (forward-line)
        (when (re-search-forward "^\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) !" 
                                 (save-excursion 
                                   (re-search-forward "^#\\+end_src" end-of-section t))
                                 t)
          (replace-match "\\1 *"))))))
#+end_src

** Date Tracking Functions

 I'm not using these right now, but might revist in the future.

#+begin_src emacs-lisp :tangle no
  (defun my/org-set-completed-date ()
    (when (equal "Done" (org-entry-get nil "STATUS"))
      (org-entry-put nil "COMPLETED"
		     (format-time-string "[%Y-%m-%d %a]"))))

  (defun my/org-set-started-date ()
    (when (equal "In-Progress" (org-entry-get nil "STATUS"))
      (org-entry-put nil "STARTED"
		     (format-time-string "[%Y-%m-%d %a]"))))

  (add-hook 'org-property-changed-functions
	    (lambda (property value)
	      (when (equal property "STATUS")
		(my/org-set-completed-date)
		(my/org-set-started-date))))
#+end_src

** Conversion Functions
#+begin_src emacs-lisp
  (defun convert-to-org ()
    "Convert current markdown buffer to org format."
    (interactive)
    (let* ((md-file (buffer-file-name))
	   (org-file (concat (file-name-sans-extension md-file) ".org")))
      (when (and md-file (file-exists-p md-file))
	(call-process "pandoc" nil nil nil
		      "-f" "markdown"
		      "-t" "org"
		      md-file
		      "-o" org-file)
	(find-file org-file))))

  (defun convert-to-markdown ()
    "Convert current org buffer to markdown format."
    (interactive)
    (let* ((org-file (buffer-file-name))
	   (md-file (concat (file-name-sans-extension org-file) ".md")))
      (when (and org-file (file-exists-p org-file))
	(call-process "pandoc" nil nil nil
		      "-f" "org"
		      "-t" "markdown"
		      org-file
		      "-o" md-file)
	(find-file md-file))))

  (defun my/move-to-custom-id-file ()
    "Move selected org item to a new file named after its CUSTOM_ID property."
    (interactive)
    (save-excursion
      (let* ((region-content (buffer-substring (region-beginning) (region-end)))
	     (custom-id (save-excursion
			  (goto-char (region-beginning))
			  (org-entry-get nil "CUSTOM_ID"))))
	(if custom-id
	    (let ((new-file (concat "~/notes/" custom-id ".org")))
	      (with-temp-file new-file
		(insert "#+TITLE: " custom-id "\n\n")
		(insert region-content))
	      (delete-region (region-beginning) (region-end))
	      (insert (format "[[file:%s][%s]]\n" new-file custom-id))
	      (message "Moved to %s" new-file))
	  (message "No CUSTOM_ID property found!")))))
#+end_src

** Agenda Configuration
#+begin_src emacs-lisp
(setq org-agenda-block-separator nil)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-timegrid-use-ampm t)
(setq org-agenda-time-leading-zero t)
(setq org-agenda-todo-keyword-format "%s")
(setq org-agenda-include-diary t)
(setq org-agenda-hide-tags-regexp ".")

;; Allow creating new nodes (including new files) when refiling
(setq org-refile-allow-creating-parent-nodes 'confirm)

;; Use the full outline paths for refile targets
(setq org-refile-use-outline-path nil)

;; Completes in steps so you can select a heading after selecting the file
(setq org-outline-path-complete-in-steps nil)

(require 'diary-lib)

(use-package org-super-agenda
  :after org-agenda
  :config
  (setq org-super-agenda-header-map nil)  
  (setq org-super-agenda-header-properties nil)
  (org-super-agenda-mode))

(setq warning-suppress-types '((org-element)))

(defun my/inherit-meeting-times ()
  "Set SCHEDULED property on meeting note TODOs based on parent timestamp."
  (interactive)
  (org-map-entries
   (lambda ()
     (when (and (string= (org-entry-get nil "CATEGORY") "meeting-notes")
	  (org-get-todo-state))
 (let ((timestamp nil))
   (save-excursion
     (when (org-up-heading-safe)
       (setq timestamp (org-entry-get nil "TIMESTAMP" t))))
   (when timestamp
     (org-schedule nil timestamp)))))
   "+CATEGORY=\"meeting-notes\"+TODO=\"TODO\""))

(setq org-agenda-custom-commands
'(("d" "daily dashboard"
   (
    (tags "+CATEGORY=\"inbox\"" 
	  ((org-agenda-overriding-header "Inbox")))
    (agenda "Schedule and Habits"
	    ((org-agenda-span 'day)
	     (org-agenda-sorting-strategy '((agenda time-up todo-state-down alpha-up)))
	     (org-agenda-overriding-header " ")
	     (org-super-agenda-groups
	      '(
		(:name "Happening today" 
		       :and(:scheduled nil :deadline nil :not(:time-grid t)))
		(:name "Today's Meeting Notes" :category "meeting-notes")
		(:name "Today's Schedule"
		       :time-grid t)
		(:name "High Priority"
        :and (:deadline today :priority "A")
        :and (:deadline past :priority "A"))
		(:name "Cooking"
        :and (:deadline today :tag "cooking")
        :and (:deadline past :tag "cooking"))
		(:name "Code Review"
        :and (:deadline today :category "code review")
        :and (:deadline past :category "code review"))
		(:name "Code Review Bunker"
        :and (:deadline today :category "code review bunker")
        :and (:deadline past :category "code review bunker"))
		(:name "Work"
        :and (:deadline today :tag "work")
        :and (:deadline past :tag "work"))
		(:name "Hard"
        :and (:deadline today :tag "hard")
        :and (:deadline past :tag "hard"))
		(:name "Quick"
        :and (:deadline today :tag "quick")
        :and (:deadline past :tag "quick"))
		(:name "Easy"
        :and (:deadline today :tag "easy")
        :and (:deadline past :tag "easy"))
		(:name "Cleaning"
        :and (:deadline today :tag "cleaning")
        :and (:deadline past :tag "cleaning"))
		(:name "Due Today"
        :and (:deadline today :tag "cleaning")
        :and (:deadline past :tag "cleaning"))
		(:name "Overdue" :deadline past)
		(:name "Due Today" :deadline today)
		(:name "High Priority (soon)" :and (:priority "A" :deadline future))
		(:name "Cooking (soon)" :and (:deadline future :tag "cooking"))
		(:name "Hard (soon)" :and (:deadline future :tag "hard"))
		(:name "Quick (soon)" :and (:deadline future :tag "quick"))
		(:name "Easy (soon)" :and (:deadline future :tag "easy"))
		(:name "Cleaning (soon)" :and (:deadline future :tag "cleaning"))
		(:name "Code Review (soon)" :and (:category "code review" :deadline today))
		(:name "Code Review Bunker (soon)" :and (:category "code review bunker" :deadline future))
		(:name "Work (soon)" :and (:deadline future :tag "work"))
		(:name "Due Soon" :deadline future)
		(:name "Active Bugs" :category "bug")
		(:name "Active Epics" :category "epic")
		;; I moved TODOs to a tags component because agenda won't show none todo/event items like logs
		;;(:name "Inbox" :category "inbox")
		;;(:name "Poetry" :category "my poems")
		(:auto-category t)
		))))))
  ("w" "Weekly overview with super-agenda"
   ((agenda ""
	    ((org-agenda-span 7)                      ;; Show 7 days
	     (org-agenda-start-on-weekday nil)        ;; Start from current day
	     (org-agenda-time-grid '((daily today require-timed)
				     (800 1000 1200 1400 1600 1800 2000)
				     "......" "----------------"))  ;; Time grid config
	     (org-agenda-include-deadlines nil)       ;; No deadlines
	     (org-agenda-skip-scheduled-if-done t)     
	     (org-agenda-skip-deadline-if-done t)
	     (org-agenda-skip-scheduled-delay-if-done t)
	     (org-agenda-skip-function                ;; Skip scheduled items
	      '(org-agenda-skip-entry-if 'scheduled 'deadline))
	     (org-agenda-prefix-format '((agenda . "%?-12t ")))  ;; Only show time
	     (org-agenda-todo-keyword-format "")
	     (org-agenda-show-all-dates t)
	     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
	     (org-agenda-format-date "%A %Y-%m-%d")
	     ;; Super agenda groups
	     (org-super-agenda-groups
	      '(
		(:name "Happening today" 
		       :and(:scheduled nil :deadline nil :not(:time-grid t)))
		(:name "Today's Schedule"
		       :time-grid t)
		))))))
  ))

(setq org-agenda-time-grid-use-ampm t)
(setq org-agenda-with-times t)
(setq org-agenda-time-format "%I:%M%p")

				  ; used with %i
				  ;(setq org-agenda-category-icon-alist 
				  ;      `(("bread"  ,(list (propertize "â€ðŸ¥–")))
				  ;        ("Music" ,(list (propertize "ðŸŽ¶" )))
				  ;        ("Home"  ,(list (propertize"ðŸ¡" )))))

(setq org-agenda-prefix-format
'((agenda . "  - %t ")
  (tags   . "â—‹ ")
  (todo   . "â—‹ ")))
#+end_src

** Calfw
#+begin_src emacs-lisp 
  (use-package calfw)
  (use-package google-maps)

  (use-package calfw-org
    :config
    (setq cfw:org-agenda-schedule-args '(:timestamp)))

  (defun my/cfw:trim-text (text)
    "Trim TEXT to fit in WIDTH, without adding ellipsis that breaks formatting."
    text)
  ;; Override the default truncation function
  (advice-add 'cfw:trim :override #'my/cfw:trim-text)
#+end_src

** Org Face Customizations
#+begin_src emacs-lisp
  (use-package org-modern
    :config
    ;; Disable org-modern's TODO keyword styling
    (setq org-modern-todo nil))
#+end_src

** Quickly Open Files (For The "Go" Menu)
#+begin_src emacs-lisp
  (defun my/open-inbox ()
    (interactive)
    "Opens the inbox.org file in the notes directory."
    (interactive)
    (find-file (expand-file-name "inbox.org" my-notes-directory)))
  (defun my/open-inbox-mobile ()
    (interactive)
    "Opens the inbox-mobile.org file in the notes directory."
    (interactive)
    (find-file (expand-file-name "inbox-mobile.org" my-notes-directory)))
  (defun my/open-emacs-config ()
    (interactive)
    "Opens the emacs.org file in the nix directory."
    (interactive)
    (find-file (expand-file-name "system/modules/emacs/default.nix" my-nix-systems-flake-directory)))
  (defun my/open-log ()
    (interactive)
    "Opens the logs.org file in the notes directory."
    (interactive)
    (find-file (expand-file-name "logs.org" my-notes-directory)))
  (defun my/open-prompts ()
    (interactive)
    "Opens the logs.org file in the notes directory."
    (interactive)
    (find-file (expand-file-name "prompts.org" my-notes-directory)))
  (defun my/open-budget ()
    (interactive)
    "Opens the logs.org file in the notes directory."
    (interactive)
    (find-file (expand-file-name "budget.org" my-notes-directory)))
#+end_src

** Working With LLM Prompts
*** Searching for a project as a prompt variable

#+begin_src emacs-lisp
  (defun my/get-project-choices ()
    "Return a list of available projects from Projectile."
    (if (and (fboundp 'projectile-known-projects)
	     (fboundp 'projectile-project-root))
	(let ((projects (projectile-known-projects))
	      (current (when (projectile-project-p)
			 (projectile-project-root))))
	  ;; Put the current project at the beginning if we're in one
	  (if current
	      (cons current (delete current projects))
	    projects))
      '("default-project")))  ;; Fallback if projectile isn't available

  (defvar my/prompt-placeholder-functions
    '(("[PROJECT]" . my/get-project-choices))
    "Alist mapping placeholder strings to functions that return choices.
  Each function should either return a string (for direct substitution)
  or a list of strings (for completion-based selection).")
#+end_src

*** Searching for a note file as a prompt variable

#+begin_src emacs-lisp
  (defun my/get-notes-files ()
    "Return a list of org note files."
    (if (boundp 'my-notes-directory)
	(let* ((default-directory my-notes-directory)
	       (all-files (directory-files-recursively my-notes-directory "\.org$" t)))
	  ;; Return the list with relative paths
	  (mapcar (lambda (file) (file-relative-name file my-notes-directory)) all-files))
      (user-error "my-notes-directory is not set")))
  (defun my/get-memorynode-link ()
    "Prompt for a Roam node and return it as a [[file:â€¦#id][title]] link."
    (let ((node (org-roam-node-read)))
      (let ((org-roam-node-formatter
	     #'org-roam-node-format--file-link))   ; bind the formatter
	(org-roam-node-formatted node))))

  (setq my/prompt-placeholder-functions
	(append my/prompt-placeholder-functions
		'(("[NOTES]" . my/get-notes-files))))
#+end_src

*** Searching for a memory file as a prompt variable
#+begin_src emacs-lisp
  (defun my/get-memorynode-link ()
    "Prompt for a Roam node and return an org link [[file:â€¦::#ID][TITLE]]."
    (let* ((node  (org-roam-node-read))
	   (id    (org-roam-node-id    node))
	   (title (org-roam-node-title node)))
      (format "[[id:%s][%s]]"
	      id
	      title)))

  (setq my/prompt-placeholder-functions
	(append
	 (assoc-delete-all "[MEMORYNODE]" my/prompt-placeholder-functions)
	 '(("[MEMORYNODE]" . my/get-memorynode-link))))
#+end_src

*** Replacing placeholder

#+begin_src emacs-lisp
  (defun my/replace-prompt-placeholders (content)
    "Replace placeholders in CONTENT string.
  Placeholders are of the form [NAME], where NAME is alphanumeric or underscore.
  Use functions in `my/prompt-placeholder-functions` for special placeholders."
    (if (null content)
	nil  ;; Return nil if content is nil
      (let ((regex "\\[\\([A-Z0-9_]+\\)\\]")
	    (result content))
	(while (and result (string-match regex result))
	  (let* ((full (match-string 0 result))
		 (name (match-string 1 result))
		 (entry (assoc full my/prompt-placeholder-functions))
		 (choice
		  (if entry
		      ;; If we have a special handler function
		      (let ((res (funcall (cdr entry))))
			(if (listp res)
			    ;; If it returns a list, use completing-read
			    (completing-read (format "%s: " name) res nil t)
			  ;; Otherwise use the direct result
			  res))
		    ;; No special handler, just ask the user
		    (read-string (format "%s: " name)))))
	    ;; Replace all occurrences of this placeholder with chosen value
	    (setq result (replace-regexp-in-string
			  (regexp-quote full) choice result t t))))
	result)))
#+end_src

*** Searching for a prompt from the library

#+begin_src emacs-lisp 
(require 'consult)

(defvar my/llm-prompts-file
  (expand-file-name "prompts.org" my-notes-directory)
  "Path to your prompts.org library.")

(defun my--build-llm-prompt-alist ()
  "Return an alist of (DISPLAY . RAW-CONTENT) for each src-block in prompts.org."
  (with-temp-buffer
    (insert-file-contents my/llm-prompts-file)
    (goto-char (point-min))
    (let (alist)
      ;; Simple regex based approach rather than using org-element
      (while (re-search-forward "^#\\+begin_src \\(.*?\\)$" nil t)
        (let* ((begin-pos (point))
               (language (match-string-no-properties 1))
               (heading "No heading") ;; Default heading if none found
               (val nil))
          ;; Find the parent heading for this src block
          (save-excursion
            (goto-char begin-pos)
            (when (re-search-backward "^\\*+ \\(.*?\\)$" nil t)
              (setq heading (match-string-no-properties 1))))
          
          ;; Get the content until end_src
          (when (re-search-forward "^#\\+end_src" nil t)
            (setq val (buffer-substring-no-properties 
                       begin-pos
                       (match-beginning 0)))
            ;; Create a preview of the content
            (let ((preview (truncate-string-to-width
                            (replace-regexp-in-string "\n" " " val)
                            60 nil nil "â€¦")))
              (push (cons (format "%s  [%s]" heading preview) val) alist)))))
      (nreverse alist))))

(defun my/search-llm-prompts ()
  "Pick a prompt from `my/llm-prompts-file', fill placeholders, and insert at point."
  (interactive)
  (unless (file-readable-p my/llm-prompts-file)
    (user-error "Cannot read prompts file %s" my/llm-prompts-file))
  ;; 1) mark our insertion point

  (let ((insert-marker (point-marker))
        prompt-alist choice raw filled)
    ;; 2) build + pick
    (setq prompt-alist (my--build-llm-prompt-alist))
    (unless prompt-alist
      (user-error "No src-blocks found in %s" my/llm-prompts-file))
    (setq choice (consult--read prompt-alist
                                :prompt        "Select prompt: "
                                :require-match t))
    (setq raw    (cdr (assoc choice prompt-alist)))
    (unless raw
      (user-error "Internal error: %S not in prompt list" choice))
    ;; 3) replace placeholders if any
    (setq filled (my/replace-prompt-placeholders raw))
    ;; 4) finally go back to the original buffer/point and insert
    (with-current-buffer (marker-buffer insert-marker)
      (goto-char (marker-position insert-marker))
      (insert (or filled raw)))))
#+end_src

** Org to epub
#+begin_src emacs-lisp :tangle no
(defun my-org-roam-to-epub ()
  "Convert current Org-roam file and its linked Roam ID files into a single EPUB using Pandoc."
  (interactive)
  (unless (and buffer-file-name (featurep 'org-roam))
    (error "Must be visiting a file with Org-roam loaded"))
  (let* ((base-file (file-truename buffer-file-name))
         (base-dir (file-name-directory base-file))
         (css-file (expand-file-name "~/Documents/epub-style.css"))
         (meta-file (expand-file-name "~/Documents/epub-meta.yaml"))
         (epub-file (concat (file-name-sans-extension base-file) ".epub"))

         ;; Collect all `id:` links and resolve to file paths
         (id-files
          (save-excursion
            (goto-char (point-min))
            (let (files)
              (while (re-search-forward "\\[\\[id:\\([A-Za-z0-9-]+\\)\\]" nil t)
                (let* ((id (match-string 1))
                       (file (org-roam-node-file (org-roam-node-from-id id))))
                  (when file (push (file-truename file) files))))
              (delete-dups (cons base-file files)))))

         ;; Build pandoc command
         (command (mapconcat #'identity
                   (remove nil
                    (append
                     '("pandoc"
                       "--from=org"
                       "--to=epub3"
                       "--toc"
                       "--toc-depth=2"
                       "--epub-chapter-level=1")
                     (when (file-exists-p css-file)
                       (list (concat "--epub-stylesheet=" (shell-quote-argument css-file))))
                     (when (file-exists-p meta-file)
                       (list (shell-quote-argument meta-file)))
                     (mapcar #'shell-quote-argument id-files)
                     (list "-o" (shell-quote-argument epub-file))))
                   " ")))

    ;; Run the command in a compilation buffer
    (compilation-start command nil
                       (lambda (_) "*pandoc-epub*"))))
#+end_src

* Which Key Configuration
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode)
    (setq which-key-idle-delay 0.3
	  which-key-prefix-prefix "â†’"
	  which-key-sort-order 'which-key-key-order-alpha
	  which-key-side-window-location 'bottom
	  which-key-side-window-max-height 0.25))
#+end_src

* Spell Checking

#+begin_src emacs-lisp 
(use-package flyspell
  :ensure nil 
  :config
  (setq ispell-program-name "aspell"))

(setq ispell-personal-dictionary "~/nix/system/with/user/with/program/emacs-dictionary.pws")

;(add-hook 'text-mode-hook
          ;(lambda ()
            ;(when (and buffer-file-name  ; Ensure it's a real file
                       ;(not (string-match-p "org-agenda-files" buffer-file-name))
                       ;(not (derived-mode-p 'org-agenda-mode)))  ; Exclude agenda buffers
              ;(flyspell-mode 1))))

(use-package flyspell-correct
  :ensure nil 
  :config
  (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-wrapper))
#+end_src

* Olivetti
#+begin_src emacs-lisp
  (use-package olivetti
    :config
    ;; Use both margins and fringes for fancy "page" look
    (setq olivetti-style 'fancy)

    ;; Define custom fringe face that works with both light/dark themes
    )

  (defun my/toggle-olivetti ()
    "Toggle olivetti mode with my preferred settings."
    (interactive)
    (if (bound-and-true-p olivetti-mode)
	(olivetti-mode -1)
      (progn
	(olivetti-mode)
	(olivetti-set-width 120))))

  (defun my/update-olivetti-fringe-face ()
    "Update olivetti-fringe face based on current theme."
    (let ((bg-color (if (eq my/current-theme 'gruvbox-light-hard)
			"#f0ead8"  
		      "#161819"))) 
      (set-face-attribute 'olivetti-fringe nil :background bg-color)))
#+end_src

(global-set-key (kbd "<f1>") 'my/toggle-olivetti)
#+end_src

* Elfeed Configuration
#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    ("C-x w" . elfeed)
    :config
    (evil-define-key 'normal elfeed-search-mode-map
		     (kbd "r") 'elfeed-search-untag-all-unread
		     (kbd "u") 'elfeed-search-tag-all-unread
		     (kbd "RET") 'elfeed-search-show-entry
		     (kbd "q") 'quit-window
		     (kbd "g") 'elfeed-update
		     (kbd "G") 'elfeed-search-update--force)

    (evil-define-key 'normal elfeed-show-mode-map
		     (kbd "r") 'elfeed-show-untag-unread
		     (kbd "u") 'elfeed-show-tag-unread
		     (kbd "q") 'quit-window
		     (kbd "n") 'elfeed-show-next
		     (kbd "p") 'elfeed-show-prev
		     (kbd "b") 'elfeed-show-visit)

    (setq elfeed-search-filter "+unread")
    (setq elfeed-sort-order 'descending))

  (use-package elfeed-protocol
    :ensure t
    :after elfeed
    :custom
    (elfeed-use-curl t)
    (elfeed-protocol-enabled-protocols '(fever))
    (setq elfeed-protocol-log-trace t)
    (elfeed-protocol-fever-update-unread-only t)
    (elfeed-protocol-fever-fetch-category-as-tag t)
    (elfeed-protocol-feeds '(("fever+https://me@homelab.rss"
			      :api-url "https://homelab.tail357e32.ts.net/rss/api/fever.php"
			      :use-authinfo t)))
    (elfeed-protocol-enabled-protocols '(fever))
    :config
    (elfeed-protocol-enable))

  (defun my/elfeed-reset ()
    "Reset elfeed database and update."
    (interactive)
    (when (yes-or-no-p "Really reset elfeed database? ")
      (let ((db (expand-file-name "~/.elfeed/index"))
	    (data (expand-file-name "~/.elfeed/data")))
	(message "Checking paths: index=%s data=%s" db data)

	;; Try to close elfeed first
	(elfeed-db-unload)
	(message "Database unloaded")

	;; Delete files with error checking
	(condition-case err
	    (progn
	      (when (file-exists-p db)
		(delete-file db)
		(message "Deleted index file"))
	      (when (file-exists-p data)
		(delete-directory data t)
		(message "Deleted data directory")))
	  (error (message "Error during deletion: %s" err)))

	;; Restart elfeed
	(elfeed)
	(elfeed-search-update--force)
	(message "Reset complete"))))

  ;; Set elfeed-show-entry-switch to display in a side window
  (setq elfeed-show-entry-switch #'elfeed-display-buffer-right)

  ;; Define the display function for right split
  (defun elfeed-display-buffer-right (buf)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer 
       buf
       '((display-buffer-reuse-window display-buffer-in-side-window)
	 (side . right)
	 (window-width . 0.5)))))

  ;; Optional: Make elfeed respect this two-pane setup when updating
  (defadvice elfeed-search-update (after configure-windows activate)
    (when (get-buffer "*elfeed-entry*")
      (elfeed-display-buffer-right (get-buffer "*elfeed-entry*"))))

  ;; Optional: Return focus to search buffer after showing entry
  (defadvice elfeed-show-entry (after switch-to-search activate)
    (select-window (get-buffer-window "*elfeed-search*")))

  ;;(require 'elfeed-tube)
  ;;(elfeed-tube-setup)
  ;;(define-key elfeed-show-mode-map (kbd "F") 'elfeed-tube-fetch)
  ;;(define-key elfeed-show-mode-map [remap save-buffer] 'elfeed-tube-save)
  ;;(define-key elfeed-search-mode-map (kbd "F") 'elfeed-tube-fetch)
  ;;(define-key elfeed-search-mode-map [remap save-buffer] 'elfeed-tube-save)
  ;;(require 'elfeed-tube-mpv)
  ;;(define-key elfeed-show-mode-map (kbd "C-c C-f") 'elfeed-tube-mpv-follow-mode)
  ;;(define-key elfeed-show-mode-map (kbd "C-c C-w") 'elfeed-tube-mpv-where)
					  ;(setq elfeed-search-title-max-width 120)
					  ;(setq elfeed-search-title-min-width 120)
					  ;(setq elfeed-search-date-format '("%Y/%m-%d %H:%M" :left))
					  ;(setq elfeed-search-filter "+unread")
#+end_src

* Org Roam Configuration
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory "/Users/me/Library/Mobile Documents/com~apple~CloudDocs/notes/roam")
    (org-roam-completion-everywhere t)
    :config
    (org-roam-db-autosync-mode)
    (setq org-roam-dailies-directory "daily/")
    (setq org-roam-dailies-capture-templates
	  '(("d" "default" entry
	     "* %?"
	     :target (file+head "%<%Y-%m-%d>.org"
				"#+title: %<%Y-%m-%d>\n")))))
#+end_src

**  Org Roam UI Configuration
#+begin_src emacs-lisp
  (use-package org-roam-ui
    :ensure t
    :after org-roam
    :custom
    (org-roam-ui-sync-theme t)
    (org-roam-ui-follow nil)
    (org-roam-ui-update-on-save t)
    (org-roam-ui-open-on-start nil)
    (org-roam-ui-find-ref-title t)
    (org-roam-ui-retitle-ref-nodes t)
    :config
    (defun org-roam-ui-open ()
      "Ensure the server is active, then open the roam graph."
      (interactive)
      (unless org-roam-ui-mode
	(org-roam-ui-mode 1))
      (browse-url (format "http://localhost:%d" org-roam-ui-port))))
#+end_src

* Path Copying Functions

#+begin_src emacs-lisp
  (defun copy-file-path ()
    "Copy the current buffer file path to the kill ring."
    (interactive)
    (let ((filepath (buffer-file-name)))
      (when filepath
	(kill-new filepath)
	(message "Copied: %s" filepath))))

  (defun copy-file-name ()
    "Copy the current buffer file name to the kill ring."
    (interactive)
    (let ((filename (file-name-nondirectory (buffer-file-name))))
      (when filename
	(kill-new filename)
	(message "Copied: %s" filename))))

  (defun copy-directory-path ()
    "Copy the current buffer directory path to the kill ring."
    (interactive)
    (let ((dirpath (file-name-directory (buffer-file-name))))
      (when dirpath
	(kill-new dirpath)
	(message "Copied: %s" dirpath))))
#+end_src

* Avy
#+begin_src emacs-lisp
  (require 'avy)
  (define-key evil-normal-state-map (kbd "s") 'avy-goto-char-timer)
#+end_src

* rg
#+begin_src emacs-lisp
  (require 'rg)
#+end_src

* Custom Commands For Projects

I use this space to write a bunch of custom commands for interacting with projects I work on frequently.

#+begin_src emacs-lisp
;; We're going to add to this down the chain
(defvar my/executer-picker-candidates nil
  "Alist mapping display names to interactive functions for `my/executer-picker'.")

(defun my/executer-picker ()
  "Pick a function via Consult and run it (interactively if possible)."
  (interactive)
  (let* ((alist (seq-filter (lambda (p) (fboundp (cdr p)))
                            my/executer-picker-candidates))
         (choice (consult--read
                  (mapcar #'car alist)
                  :prompt "Run function: "
                  :require-match t
                  :annotate (lambda (cand)
                              (let* ((sym (cdr (assoc cand alist)))
                                     (doc (and sym (documentation sym))))
                                (when doc
                                  (concat "  " (car (split-string doc "\n")))))))))
    (let ((sym (cdr (assoc choice alist))))
      (unless sym (user-error "No function for choice: %s" choice))
      (if (commandp sym) (call-interactively sym) (funcall sym)))))
#+end_src

#+begin_src emacs-lisp
(defun my/projectile-run-command-in-selected-project (command)
  "Use `projectile-switch-project` to select a project, then run COMMAND
in that project's root using `compile` in a project-named buffer.
Interactively, prompt for COMMAND using `compile-history`."
  (interactive (list (read-string "Command: " nil 'compile-history)))
  (require 'projectile)
  (let* ((cmd command)
         (projectile-switch-project-action
          (lambda ()
            (let* ((root (projectile-project-root))
                   (default-directory root)
                   (proj (file-name-nondirectory (directory-file-name root)))
                   (compilation-buffer-name-function
                    (lambda (_mode) (format "*compile-%s-%s*" proj command))))
              (compile cmd t)))))
    (projectile-switch-project)))
#+end_src

#+begin_src emacs-lisp
  (defun scan-worktree-projects ()
    "Scan for all worktree directories and add them to Projectile."
    (interactive)
    (let ((base-dir (expand-file-name "~/binwarden/")))
      (dolist (owner-repo (directory-files base-dir t "^[^.]"))
	(when (file-directory-p owner-repo)
	  (dolist (branch-dir (directory-files owner-repo t "^[^.]"))
	    (when (and (file-directory-p branch-dir)
		       (file-exists-p (expand-file-name ".git" branch-dir)))
	      (projectile-add-known-project branch-dir)))))))

  (with-eval-after-load 'projectile
    (scan-worktree-projects))
#+end_src

** Enable complex color support in compile buffers

#+begin_src emacs-lisp
  (use-package ansi-color
    :config
    (defun my/colorize-compilation ()
      "Colorize from `compilation-filter-start' to `point'."
      (let ((inhibit-read-only t))
	(ansi-color-apply-on-region
	 compilation-filter-start (point))))

    (add-hook 'compilation-filter-hook #'my/colorize-compilation)

    (setq ansi-color-for-comint-mode t)
    (setq comint-terminfo-terminal "xterm-256color"))
#+end_src

#+RESULTS:
: t

** Builds for the Bitwarden Nx PoC project

#+begin_src emacs-lisp
  (defun bitwarden/nx-poc-npm-i ()
    "Run npm ci in the nx PoC"
    (interactive)
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-functionl 
	    (lambda (_mode) (format "*nx-poc-npm-i*"))))
      (compile "npm i" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-web ()
    "Build the web vault of the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/web"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-web-build*"))))
      (compile "npm run build:watch" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-browser-chrome ()
    "Build the chrome extension of the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/browser"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-chrome-build*"))))
      (compile "npm run build:watch:chrome" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-browser-firefox ()
    "Build the chrome extension of the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/browser"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-firefox-build*"))))
      (compile "npm run build:watch:firefox" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-desktop ()
    "Build the desktop applicaton in the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/desktop"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-desktop-build*"))))
      (compile "npm run build:watch" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/build-nx-poc-cli ()
    "Build the cli in the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/cli"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-cli-build*"))))
      (compile "npm run build" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx-poc-nx-report ()
    "Runs nx report in the poc project"
    (interactive)
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-nx-report*"))))
      (compile "npx nx report" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx/build (target)
    "Build the NX poc using NX for TARGET"
    (interactive
     (list (completing-read "Target to build: " 
			    '("common" "angular" "web" "cli" "desktop" "browser")
			    nil nil nil nil "common")))
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-pox-%s-build*" target))))
      (compile (format "npx nx build %s" target) t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx/serve (target)
    "Serve the NX poc using NX for TARGET"
    (interactive
     (list (completing-read "Target to build: " 
			    '("web" "desktop" "browser")
			    nil nil nil nil "web")))
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-pox-%s-serve*" target))))
      (compile (format "npx nx serve %s" target) t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx/start (target)
    "Start the NX poc using NX for TARGET"
    (interactive
     (list (completing-read "Target to build: " 
			    '("cli")
			    nil nil nil nil "cli")))
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-pox-%s-start*" target))))
      (compile (format "npx nx start %s --verbose" target) t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx/cleanup ()
    "Clean up the nx poc project"
    (interactive)
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-cleanup*"))))
      (compile "rm -rf node_modules ; rm -rf .nx" t)))
#+end_src

** My Nix Systems Configuration

#+begin_src emacs-lisp
(defun my/nix/rebuild (system)
  "Rebuild my nix config for the specified SYSTEM.
If SYSTEM is 'homelab', runs rebuild over SSH as root using ~/.ssh/me identity,
runs 'nix-collect-garbage' and then the rebuild."
  (interactive
   (list (completing-read "System to rebuild: " 
			  '("air" "bw" "homelab")
			  nil nil nil nil "air")))
  (let* ((default-directory (my/get-project-path "nix"))
	 (compilation-buffer-name-function 
	  (lambda (_mode) (format "*nix-%s-rebuild*" system)))
	 command)
    (if (string= system "homelab")
	(setq command 
	      (string-join
	       '("ssh -o StrictHostKeyChecking=no"
		 "-i ~/.ssh/me"
		 "root@homelab"
		 "\"nix-collect-garbage && nixos-rebuild switch --flake github:addisonbeck/nix#homelab\"")
	       " "))
      (setq command (format "nix develop --command sudo rebuild %s" system)))
    (compile command t)))
#+end_src

#+RESULTS:
: my/nix-rebuild

#+begin_src emacs-lisp
  (defun my/nix/format ()
    "Run the formatters in my nix systems configuration"
    (interactive)
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-format*"))))
      (compile "nix develop --command apply formatting" t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/collect-garbage ()
    "Run the nix garbage collector"
    (interactive)
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-flake-update*"))))
      (compile "nix-collect-garbage -d" t)))
#+end_src

#+RESULTS:
: my/nix-format

#+begin_src emacs-lisp
  (defun my/nix/commit (message)
    "Commit all files in my nix config with MESSAGE"
    (interactive
     (list (read-string "Commit message: " nil nil nil)))
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-commit*"))))
      (compile (format "git add . ; git commit -m %s ; git pull ; git push" message) t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/flake-update ()
    "Update flake lock in my nix systems config"
    (interactive)
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-flake-lock-update*"))))
      (compile "nix flake update" t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/check-status ()
    "Check the git status of my nix systems config"
    (interactive)
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-git-status*"))))
      (compile "git status" t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/update-minecraft-packwize ()
    "Update the pacckages for the packwiz server for my kids"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nix") "/packwiz/bonesfamily"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-packwiz-packages*"))))
      (compile "packwiz " t)))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'my/executer-picker-candidates
             '("nix: update flake" . my/nix/flake-update))

(add-to-list 'my/executer-picker-candidates
             '("nix: format" . my/nix/format))

(add-to-list 'my/executer-picker-candidates
             '("nix: rebuild" . my/nix/rebuild))

#+end_src

** My notes

#+begin_src emacs-lisp
  (defun my/quick-commit (message)
    "Commit all files in my notes with MESSAGE"
    (interactive
     (list (read-string "Commit message: " nil nil nil)))
    (let* ((default-directory (my/get-project-path "notes"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*notes-commit*"))))
      (compile (format "git add . ; git commit -m %s ; git pull ; git push" message) t)))
#+end_src

#+RESULTS:
: my/nix-commit

** Workspace

#+begin_src emacs-lisp
  (defun my/worktree-build ()
    (interactive)
    (let ((default-directory (projectile-project-root)))
      (compile (or (getenv "BUILD_CMD") "make"))))
#+end_src

#+begin_src emacs-lisp
  (defun my/worktree-test ()
    (interactive)
    (let ((default-directory (projectile-project-root)))
      (compile (or (getenv "TEST_CMD") "make test"))))
#+end_src
** Binwarden

#+begin_src emacs-lisp
  (defun binwarden/create-worktree ()
    "Create a new worktree in the binwarden directory.
    1. Select a repository from binwarden directory
    2. Enter a name for the new worktree
    3. Optionally select a source branch (sorted by recent commit date)
    4. Run \'just create-worktree\' with those parameters"
    (interactive)
    (let* ((binwarden-dir (expand-file-name "~/binwarden/"))
	   (repos (directory-files binwarden-dir nil "^[^.]"))
	   (selected-repo (completing-read "Select repository: " repos))
	   (worktree-name (read-string "Worktree name: "))
	   ;; Parse the repo name to find the primary branch from .env file
	   (owner (car (split-string selected-repo "-")))
	   (repo (cadr (split-string selected-repo "-")))
	   (env-var-name (format "PRIMARY_%s_%s_WORKTREE" 
				 (upcase owner) (upcase repo)))
	   (env-file (expand-file-name ".env" binwarden-dir))
	   (primary-branch 
	    (when (file-exists-p env-file)
	      (with-temp-buffer
		(insert-file-contents env-file)
		(when (re-search-forward (concat "^" env-var-name "=\\(.*\\)$") nil t)
		  (match-string 1)))))
	   ;; Set directory to the primary branch worktree for getting branch list
	   (primary-worktree-dir 
	    (expand-file-name (concat selected-repo "/" (or primary-branch "main")) 
			      binwarden-dir))
	   ;; Get branches sorted by commit date from the primary worktree
	   (default-directory primary-worktree-dir)
	   (branches-raw (shell-command-to-string "git branch --sort=-committerdate"))
	   ;; Clean up branch names - remove any leading symbols (*, +, etc) and whitespace
	   (branches (mapcar (lambda (branch) 
			       (string-trim (replace-regexp-in-string "^[\\*\\+ ]+" "" branch)))
			     (split-string branches-raw "\n" t)))
	   ;; Prompt for optional source branch
	   (from-branch (completing-read "Source branch (optional, empty for default): " 
					 branches nil nil nil nil ""))
	   (from-branch-arg (if (string-empty-p from-branch)
				""
			      (format " %s" from-branch)))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*create-worktree-%s-%s*" selected-repo worktree-name))))
      (compile (format "cd %s && just create-worktree %s %s%s" 
		       (shell-quote-argument binwarden-dir)
		       selected-repo worktree-name from-branch-arg) t)))
#+end_src

#+RESULTS:
: binwarden/create-worktree

* Custom magit functions
** Reset current buffer
#+begin_src emacs-lisp
  (defun reset-file-to-revision ()
    "Reset the current buffer's file to a specified revision using Magit."
    (interactive)
    (require 'magit)
    (let* ((file-path (buffer-file-name))
	   (default-directory (magit-toplevel))
	   (revision (magit-read-branch-or-commit "Reset file to revision")))
      (when (and file-path revision)
	(let ((relative-file-path (file-relative-name file-path default-directory)))
	  (magit-run-git "checkout" revision "--" relative-file-path)
	  (revert-buffer t t t)
	  (message "File reset to %s" revision)))))
#+end_src
** View PR Check

#+begin_src emacs-lisp
  (defun my/run-gh-pr-checks ()
    "Run 'gh pr checks' for the current PR with better formatting."
    (interactive)
    (when (eq major-mode 'forge-pullreq-mode)
      (let* ((pr (forge-current-topic))
	     (pr-number (oref pr number))
	     (buffer-name (format "*gh-pr-checks:#%s*" pr-number))
	     (cmd (format "gh pr checks %s --json name,state,link" pr-number)))
	(with-current-buffer (get-buffer-create buffer-name)
	  (let ((inhibit-read-only t))
	    (erase-buffer)
	    (shell-command cmd (current-buffer))
	    (goto-char (point-min))
	    (let* ((json-data (json-read))
		   (checks (append json-data nil))
		   (passed 0)
		   (failed 0)
		   (pending 0)
		   (failed-jobs '()))

	      ;; Count statuses and collect failed jobs
	      (dolist (check checks)
		(let ((state (cdr (assoc 'state check))))
		  (cond
		   ((string= state "SUCCESS") (cl-incf passed))
		   ((string= state "FAILURE") 
		    (cl-incf failed)
		    (push check failed-jobs))
		   (t (cl-incf pending)))))

	      ;; Clear and format buffer
	      (erase-buffer)
	      (insert (propertize (format "PR #%s Checks Summary\n\n" pr-number)
				  'face '(:weight bold :height 1.2)))
	      (insert (format "Total: %d | " (length checks)))
	      (insert (propertize (format "Passed: %d | " passed)
				  'face '(:foreground "green")))
	      (insert (propertize (format "Failed: %d | " failed)
				  'face '(:foreground "red" :weight bold)))
	      (insert (propertize (format "Pending: %d\n\n" pending)
				  'face '(:foreground "orange")))

	      ;; Add detailed listing
	      (insert (propertize "All Checks:\n" 'face '(:weight bold)))
	      (dolist (check checks)
		(let* ((name (cdr (assoc 'name check)))
		       (state (cdr (assoc 'state check)))
		       (link (cdr (assoc 'link check)))
		       (state-face (cond
				    ((string= state "SUCCESS") '(:foreground "green"))
				    ((string= state "FAILURE") '(:foreground "red"))
				    (t '(:foreground "orange")))))
		  (insert "â€¢ ")
		  (insert (propertize (format "%-50s" (truncate-string-to-width name 50))
				      'face '(:weight bold)))
		  (insert " - ")
		  (insert (propertize state 'face state-face))
		  (when link
		    (insert " [")
		    (insert-text-button "Link"
					'action (lambda (_) (browse-url link))
					'follow-link t)
		    (insert "]"))
		  (insert "\n")))

	      ;; Add failed jobs section
	      (when failed-jobs
		(insert "\n")
		(insert (propertize "Failed Jobs:\n" 
				    'face '(:foreground "red" :weight bold)))
		(dolist (job failed-jobs)
		  (let ((name (cdr (assoc 'name job)))
			(link (cdr (assoc 'link job))))
		    (insert "â€¢ ")
		    (insert (propertize name 'face '(:foreground "red")))
		    (when link
		      (insert " â†’ ")
		      (insert-text-button "Open in Browser"
					  'action (lambda (_) (browse-url link))
					  'follow-link t))
		    (insert "\n")))))

	    (special-mode)
	    (goto-char (point-min))
	    (display-buffer (current-buffer)))))))
#+end_src

#+begin_src emacs-lisp
(defun my/rerun-failed-gh-pr-checks ()
  "Rerun failed checks for the current PR using GitHub CLI."
  (interactive)
  (when (eq major-mode 'forge-pullreq-mode)
    (let* ((pr (forge-current-topic))
           (pr-number (oref pr number))
           ;; Use the JSON format that matches what gh pr checks outputs
           (cmd (format "gh pr checks %s --json name,databaseId,status,conclusion" pr-number))
           failed-jobs)
      
      ;; Get failed jobs
      (message "Fetching checks for PR #%s..." pr-number)
      (let ((json-output (shell-command-to-string cmd)))
        (condition-case err
            (let ((json-object (json-read-from-string json-output)))
              (setq failed-jobs
                    (seq-filter (lambda (job)
                                  (and (alist-get 'conclusion job nil nil #'equal)
                                       (string= (alist-get 'conclusion job) "failure")))
                                json-object)))
          (error
           (message "Error parsing JSON: %S\nOutput was: %s" err (substring json-output 0 100))
           (setq failed-jobs nil))))
      
      (if (null failed-jobs)
          (message "No failed jobs to rerun!")
        (when (yes-or-no-p (format "Rerun %d failed check(s)? " (length failed-jobs)))
          (let ((rerun-buffer (get-buffer-create "*gh-rerun-checks*"))
                (counter 0))
            (with-current-buffer rerun-buffer
              (let ((inhibit-read-only t))
                (erase-buffer)
                (insert (propertize "Rerunning failed checks...\n\n" 'face '(:weight bold)))
                
                (dolist (job failed-jobs)
                  (let* ((name (alist-get 'name job))
                         (id (alist-get 'databaseId job))
                         (rerun-cmd (format "gh run rerun %s" id)))
                    (insert (format "â€¢ Rerunning: %s (ID: %s)..." name id))
                    (let ((result (shell-command-to-string rerun-cmd)))
                      (if (string-match-p "Failed\\|Error" result)
                          (insert (propertize " Failed\n" 'face '(:foreground "red")))
                        (progn
                          (cl-incf counter)
                          (insert (propertize " Triggered\n" 'face '(:foreground "green")))))))
                
                (insert (propertize (format "\nSuccessfully triggered %d/%d job reruns." 
                                           counter (length failed-jobs))
                                   'face '(:weight bold)))
                (special-mode)
                (goto-char (point-min))
                (display-buffer (current-buffer)))))))))))
#+end_src

** View reviews for PR

#+begin_src elisp
(defun my/gh-pr-reviewers ()
  "Fetch and display reviewers for the current PR using GitHub CLI."
  (interactive)
  (when (eq major-mode 'forge-pullreq-mode)
    (let* ((pr (forge-current-topic))
           (pr-number (oref pr number))
           (buffer-name (format "*gh-pr-reviewers:#%s*" pr-number))
           (cmd-reviews (format "gh pr view %s --json reviews,reviewRequests,latestReviews" pr-number))
           (cmd-raw (format "gh pr view %s --json isDraft,title" pr-number)))
      (with-current-buffer (get-buffer-create buffer-name)
        (let ((inhibit-read-only t))
          (erase-buffer)
          
          ;; Get basic PR data first
          (shell-command cmd-raw (current-buffer))
          (goto-char (point-min))
          
          (condition-case raw-err
              (let* ((raw-data (json-read))
                     (is-draft (cdr (assoc 'isDraft raw-data)))
                     (title (cdr (assoc 'title raw-data))))
                
                ;; Get review data
                (erase-buffer)
                (shell-command cmd-reviews (current-buffer))
                (goto-char (point-min))
                
                (condition-case review-err
                    (let* ((json-data (json-read))
                           (reviews (or (cdr (assoc 'reviews json-data)) []))
                           (latest-reviews (or (cdr (assoc 'latestReviews json-data)) []))
                           (review-requests (or (cdr (assoc 'reviewRequests json-data)) []))
                           (approved 0)
                           (changes-requested 0)
                           (commented 0)
                           (pending (length review-requests)))
                      
                      ;; Count latest review statuses
                      (dotimes (i (length latest-reviews))
                        (let* ((review (aref latest-reviews i))
                               (state (cdr (assoc 'state review))))
                          (cond
                           ((string= state "APPROVED") (cl-incf approved))
                           ((string= state "CHANGES_REQUESTED") (cl-incf changes-requested))
                           ((string= state "COMMENTED") (cl-incf commented)))))
                      
                      ;; Clear and format buffer
                      (erase-buffer)
                      (insert (propertize (format "PR #%s Reviewers Summary %s\n\n" 
                                                 pr-number 
                                                 (if is-draft "[DRAFT]" ""))
                                         'face '(:weight bold :height 1.2)))
                      (insert (format "Title: %s\n\n" title))
                      (insert (format "Total Reviews: %d | " (length reviews)))
                      (insert (propertize (format "Approved: %d | " approved)
                                         'face '(:foreground "green" :weight bold)))
                      (insert (propertize (format "Changes Requested: %d | " changes-requested)
                                         'face '(:foreground "red" :weight bold)))
                      (insert (propertize (format "Commented: %d\n" commented)
                                         'face '(:foreground "blue")))
                      (insert (propertize (format "Requested Reviews: %d\n" pending)
                                         'face '(:foreground "orange")))
                      
                      ;; Add latest reviews section
                      (when (> (length latest-reviews) 0)
                        (insert "\n")
                        (insert (propertize "Latest Reviews by Reviewer:\n" 'face '(:weight bold)))
                        (dotimes (i (length latest-reviews))
                          (let* ((review (aref latest-reviews i))
                                 (author (cdr (assoc 'author review)))
                                 (login (cdr (assoc 'login author)))
                                 (state (cdr (assoc 'state review)))
                                 (submitted-at (cdr (assoc 'submittedAt review)))
                                 (body (cdr (assoc 'body review)))
                                 (state-face (cond
                                              ((string= state "APPROVED") '(:foreground "green"))
                                              ((string= state "CHANGES_REQUESTED") '(:foreground "red"))
                                              (t '(:foreground "blue")))))
                            (insert "â€¢ ")
                            (insert (propertize (format "%-20s" login)
                                               'face '(:weight bold)))
                            (insert " - ")
                            (insert (propertize 
                                     (format "%-15s" 
                                            (cond
                                             ((string= state "APPROVED") "Approved")
                                             ((string= state "CHANGES_REQUESTED") "Changes Requested")
                                             (t "Commented")))
                                     'face state-face))
                            (insert " - ")
                            (insert (format "%s" (format-time-string "%Y-%m-%d" 
                                                                    (date-to-time submitted-at))))
                            (when (and body (not (string= body "")))
                              (insert "\n    ")
                              (insert (propertize (truncate-string-to-width 
                                                  (replace-regexp-in-string "\n" " " body) 70)
                                                 'face '(:slant italic))))
                            (insert "\n"))))
                      
                      ;; Add pending/requested reviewers section
                      (when (> pending 0)
                        (insert "\n")
                        (insert (propertize (if is-draft 
                                              "Assigned Reviewers (will be notified when ready):\n" 
                                             "Requested Reviewers:\n")
                                           'face '(:foreground "orange" :weight bold)))
                        
                        (dotimes (i (length review-requests))
                          (let* ((request (aref review-requests i))
                                 (requestee (cdr (assoc 'requestedReviewer request))))
                            (when requestee
                              (let ((login (cdr (assoc 'login requestee)))
                                    (team-slug (and (assoc 'slug requestee) (cdr (assoc 'slug requestee)))))
                                (when (or login team-slug)
                                  (insert "â€¢ ")
                                  (insert (propertize (or login (concat "Team: " team-slug))
                                                     'face '(:foreground "orange")))
                                  (insert "\n")))))))
                      
                      (special-mode)
                      (goto-char (point-min)))
                  (error
                   (erase-buffer)
                   (insert (format "Error parsing review data: %s\n\n" review-err))
                   (insert "Raw output from gh command:\n\n")
                   (insert (shell-command-to-string cmd-reviews)))))
            (error
             (erase-buffer)
             (insert (format "Error parsing basic PR data: %s\n\n" raw-err))
             (insert "Raw output from gh command:\n\n")
             (insert (shell-command-to-string cmd-raw)))))
          
        (display-buffer (current-buffer))))))
#+end_src

#+RESULTS:
: my/gh-pr-reviewers

* Rustis

#+begin_src
(use-package rust-mode
  :init
  (setq rust-mode-treesitter-derive t))
#+end_src
* Ledger
#+begin_src elisp
(require 'ledger-mode)
(add-to-list 'auto-mode-alist '("\\.ledger\\'" . ledger-mode))
(setq ledger-default-date-format "%Y-%m-%d")
(add-hook 'ledger-mode-hook
          (lambda ()
            (setq-local completion-cycle-threshold t)
            (setq-local tab-always-indent 'complete)))
#+end_src

* gnus
#+begin_src emacs-lisp
  (require 'gnus)
  (require 'smtpmail)
  (require 'message)
  (require 'oauth2) ;; For OAuth2 support with Gmail

  (setq user-full-name "Addison Beck")
  (setq user-mail-address "me@addisonbeck.com")

  ;; Show all messages in all groups
  (setq gnus-parameters
	'((".*" (display . all))))  

  ;; Show all groups, including empty ones
  (setq gnus-permanently-visible-groups ".*")

  ;; This shows all kinds of neat but verbose and annoying header information
  ;;(setq gnus-show-all-headers t)

  ;; Make 'A r' (gnus-summary-refer-article) the default listing function
  (setq gnus-summary-goto-unread nil)

  ;; Always start with 'A A' behavior (show all articles)
  (add-hook 'gnus-select-group-hook 'gnus-group-list-all-groups)

    ;;; Main Select Method (Primary Account)
  (setq gnus-select-method
	'(nnimap "primary-account"
		 (nnimap-address "box.addisonbeck.com")
		 (nnimap-server-port 993)
		 (nnimap-stream ssl)
		 (nnmail-expiry-wait immediate)))
#+end_src

#+begin_src emacs-lisp 
  ;;; OAuth2 setup for Gmail
  (defun get-gmail-oauth2-token ()
    "Get OAuth2 access token for Gmail."
    (let* ((auth-info (nth 0 (auth-source-search :host "oauth2.googleapis.com" 
						 :user "935901585839-b1c4q3mmjb4tuutgpd3aratopq7tf85k.apps.googleusercontent.com" 
						 :service "oauth2")))
	   (client-id (plist-get auth-info :user))
	   (client-secret (let ((secret (plist-get auth-info :secret)))
			    (if (functionp secret)
				(funcall secret)
			      secret)))
	   (token (oauth2-token-access-token
		   (oauth2-refresh-access
		    (oauth2-auth-and-store
		     "https://accounts.google.com/o/oauth2/auth"
		     "https://oauth2.googleapis.com/token"
		     client-id
		     client-secret
		     "https://mail.google.com/" nil)))))
      token))

  ;; Override auth function for Gmail accounts
  (defun gmail-oauth2-auth (server)
    "Return the OAuth2 string for SERVER."
    (when (string-match "imap.gmail.com" server)
      (let ((token (get-gmail-oauth2-token)))
	(when token
	  (concat "user=addison@bitwarden.com\001auth=Bearer " 
		  token "\001\001")))))

  ;; Register auth function
  ;;(add-to-list 'nnimap-authenticator-alist
  ;;'(gmail-oauth2 gmail-oauth2-auth))

  ;; Use the OAuth2 authenticator with Gmail
  (setq nnimap-authinfo-file "~/.authinfo")
					  ;(setq nnimap-authenticator 'gmail-oauth2)
#+end_src

#+begin_src emacs-lisp 
(defun nnimap-xoauth2-oauth2-request (user server)
  "Return the OAuth2 string for USER on SERVER."
  (when (string-match "imap.gmail.com" server)
    (let ((token (get-gmail-oauth2-token)))
      (when token
        (concat "user=" user "\001auth=Bearer " token "\001\001")))))

;;; Secondary Accounts
(add-to-list 'gnus-secondary-select-methods
             '(nnimap "work-gmail"
               (nnimap-address "imap.gmail.com")
               (nnimap-server-port 993)
               (nnimap-authenticator xoauth2)  
               (nnimap-stream ssl)
               (nnmail-expiry-target "nnimap+work-gmail:[Gmail]/Trash")
               (nnmail-expiry-wait immediate)))

;;; Add more accounts as needed
;;(add-to-list 'gnus-secondary-select-methods
             ;;'(nnimap "personal"
               ;;(nnimap-address "imap.personal.com")
               ;;(nnimap-server-port 993)
               ;;(nnimap-stream ssl)))
#+end_src

#+begin_src emacs-lisp
  ;;; SMTP configuration with account selection
  (require 'smtpmail-multi)

  ;; Define email accounts
  (setq smtpmail-multi-accounts
	'((personal . ("me@addisonbeck.com"
		       "box.addisonbeck.com"
		       465
		       "me@addisonbeck.com"
		       nil
		       starttls))
	  (work-gmail . ("addison@bitwarden.com"
			 "smtp.gmail.com" 
			 587
			 "addison@bitwarden.com"
			 nil
			 starttls))))

  ;; Set default account
  (setq smtpmail-multi-default-account 'personal)

  ;; Use smtpmail-multi as the send function
  (setq send-mail-function 'smtpmail-multi-send-it
	message-send-mail-function 'smtpmail-multi-send-it)
#+end_src

#+begin_src emacs-lisp 
;;; Posting Styles - automatically set From, signature, etc. based on context
(setq gnus-posting-styles
      '((".*" ;; Default style
         (name "Addison Beck")
         (address "me@addisonbeck.com")
         (signature "Thanks,\nAddison"))
        ("work-gmail"
         (name "Addison Beck") 
         (address "addison@bitwarden.com")
         (organization "Bitwarden"))
        ;; Match based on recipient address
        ((header "to" "client@example\\.com")
         (address "work@gmail.com")
         (signature "Professional signature for clients"))
        ;; Add more context-specific styles as needed
        ))
#+end_src

#+begin_src emacs-lisp
  ;;; Gmail-specific settings
  (setq gnus-parameters
	'(("work-gmail"
	   (display . all)
	   (posting-style
	    (name "Addison Beck")
	    (address "addison@bitwarden.com")
	    (signature "Thanks,\nAddison")))
	  ("nnimap\\+work-gmail:\\[Gmail\\]/Sent Mail"
	   (gcc-self . none))
	  ("nnimap\\+work-gmail:\\[Gmail\\]/Trash"
	   (expiry-wait . immediate))))

  ;; Gmail doesn't need to save sent mail (it does this automatically)
  (setq gnus-message-archive-group
	'((if (string-match "gmail\\.com" (message-sendmail-envelope-from))
	      nil  ;; No need to save for Gmail
	    "sent"))) ;; Archive for other accounts
#+end_src

#+begin_src emacs-lisp 
(setq gnus-topic-topology 
      '(("Gnus" visible)
        (("Personal" visible)
         (("personal" visible)))
        (("Work" visible)
         (("work-gmail" visible)))))

(setq gnus-topic-alist
      '(("personal" . ("nnimap+personal:INBOX"))
        ("work-gmail" . ("nnimap+work-gmail:INBOX"
                         "nnimap+work-gmail:[Gmail]/Sent Mail"
                         "nnimap+work-gmail:[Gmail]/All Mail"))
        ("Gnus" . ("nndraft:drafts"))))
#+end_src

#+begin_src emacs-lisp
  ;; Open articles in a vertical split
  (gnus-add-configuration
   '(article
     (horizontal 1.0
		 (summary 0.5 point)
		 (article 1.0))))

  ;; Sort by reverse number (newest first)
  (setq gnus-thread-sort-functions
	'((not gnus-thread-sort-by-number)))
  (setq gnus-article-sort-functions
	'((not gnus-article-sort-by-number)))
#+end_src

#+begin_src emacs-lisp
  (gnus-demon-add-handler 'gnus-group-get-new-news 5 t)
  (gnus-demon-init)
#+end_src

* Magit
#+begin_src emacs-lisp
  (setq magit-git-executable "/Users/me/.nix-profile/bin/git")
#+end_src

* Minibuffer Enhancement

This cool and lame at the same time

#+begin_src emacs-lisp :tangle no
;; Make minibuffer more comfortable for text entry
;; Allow the minibuffer to be resized automatically
;;(setq resize-mini-windows t)
(setq max-mini-window-height 0.5) ;; Allow up to half the frame height

;; Improved minibuffer appearance
				  ;(set-face-attribute 'minibuffer-prompt nil :weight 'bold :foreground "#5FAFD7")

;; Use miniedit for better text editing in minibuffer
(use-package miniedit
  :ensure t
  :config
  (miniedit-install)
  ;; Add a message to show usage in minibuffer prompts
  (add-hook 'minibuffer-setup-hook
      (lambda ()
	(when (> (frame-width) 80) ;; Only show if we have room
	  (message "Use C-M-e for full buffer editing")))))

;; Floating minibuffer with mini-frame
(use-package mini-frame
  ;;:if window-system  ;; Only use in GUI mode
  :ensure t
  :custom
  (mini-frame-show-parameters
   '((top . 0.35)
     (width . 0.7)
     (left . 0.5)))
  :config
  ;; Specify which commands should NOT use mini-frame
  (setq mini-frame-ignore-commands
  '(consult-line
    consult-outline
    consult-mark
    consult-imenu
    eval-expression
    "^ivy-"
    "^swiper$"))
  (mini-frame-mode 1))

;; Automatically apply olivetti-mode in miniedit buffers for nicer text editing
(defun my/setup-miniedit-buffer ()
  "Set up the miniedit buffer for comfortable editing."
  (when (string-match "\\*MiniEdit\\*" (buffer-name))
    (when (fboundp 'olivetti-mode)
(olivetti-mode 1)
(setq-local olivetti-body-width 80))
    (visual-line-mode 1)))

(add-hook 'text-mode-hook 'my/setup-miniedit-buffer)
#+end_src

* Transient Menus
** The "Go" Menu
#+begin_src emacs-lisp
(defun my/projectile-magit-status ()
  "Select a project via Projectile, then open Magit in that project."
  (interactive)
  (require 'projectile)
  (let ((projectile-switch-project-action #'magit-status))
    (projectile-switch-project)))
#+end_src
#+begin_src emacs-lisp
(transient-define-prefix my/inbox-menu ()
  "Transient menu for getting to my inboxes"
  ["Submenu Actions"
   ("i" "Inbox" my/open-inbox)
   ("m" "Mobile Inbox" my/open-inbox-mobile)])

(transient-define-prefix my/go-menu ()
  "Transient menu for navigating key files."
  ["Go To"
   ("i" "Inboxes" my/inbox-menu)
   ("a" "Agenda" my/org-agenda-daily-dashboard)
   ("e" "Emacs Config" my/open-emacs-config)
   ("g" "Follow link" org-open-at-point)
   ("p" "Prompts" my/open-prompts)
   ("b" "Budget" my/open-budget)
   ("m" "Magit" my/projectile-magit-status)
   ("l" "Log" my/open-log)])
#+end_src
** The "Insert" Menu
#+begin_src emacs-lisp
(defun my/projectile-insert-org-link-to-file ()
  "Pick a project, then a file, and insert an Org link at point in the original buffer."
  (interactive)
  (require 'projectile)
  (require 'org)
  (let* ((origin-buf (current-buffer))
         (origin-pos (copy-marker (point) t))
         (projectile-switch-project-action
          (lambda ()
            (let* ((root (projectile-project-root))
                   (file (projectile-completing-read
                          "File: " (projectile-project-files root)))
                   (abs  (expand-file-name file root))
                   (link (org-link-make-string
                          (concat "file:" (file-truename abs))
                          (file-name-nondirectory abs))))
              (when (buffer-live-p origin-buf)
                (with-current-buffer origin-buf
                  (goto-char origin-pos)
                  (insert link)))))))
    (unwind-protect
        (save-window-excursion
          (projectile-switch-project))
      (set-marker origin-pos nil))))
#+end_src
#+begin_src emacs-lisp
(transient-define-prefix my/insert-menu ()
		   "Transient menu for inserting stuff places (usually under the cursor)."
		   ["Insert"
		    ("l" "LLM Prompt" my/search-llm-prompts)
        ("p" "Projectile File" my/projectile-insert-org-link-to-file)
		    ("m" "Memory Link" org-roam-node-insert)])
#+end_src
#+begin_src emacs-lisp :tangle no
(defun my/org-send-current-buffer-to-kindle (&optional title)
  "Export current Org buffer to EPUB and email to Kindle via org-to-kindle-send."
  (interactive)
  (when (buffer-modified-p) (save-buffer))
  (let* ((file (buffer-file-name))
         (ttl (or title (or (save-excursion
                              (goto-char (point-min))
                              (when (re-search-forward "^#\\\\+TITLE: *\\\\(.*\\\\)$" nil t)
                                (match-string 1)))
                            (file-name-nondirectory file))))
         (cmd (format "org-to-kindle-send --file %s --title %s"
                      (shell-quote-argument file)
                      (shell-quote-argument ttl))))
    (message "Sending to Kindle: %s" ttl)
    (let ((ret (call-process-shell-command cmd)))
      (if (= ret 0) (message "Sent: %s" ttl) (user-error "Failed (exit=%s)" ret)))))
#+end_src
** The "Search" Menu

#+begin_src emacs-lisp
  (defun my/search-notes ()
    "Run projectile ripgrep search in the notes directory."
    (interactive)
    (let ((default-directory (my/get-project-path "notes")))
      (projectile-find-file)))

  (transient-define-prefix my/search-menu ()
			   "Transient menu for searching around the buffer(s), project, and filesystem."
			   ["Search"
			    ("s" "Line" consult-line)
			    ("b" "Buffer" consult-buffer)
			    ("f" "Find" consult-find)
			    ("o" "Org Heading" consult-org-heading)
			    ("m" "Memory" org-roam-node-find)
			    ("r" "Ripgrep" consult-ripgrep)
			    ("n" "Notes" my/search-notes)])
#+end_src

** The "Create" Menu

It would be cool if this also had some kind of interactive starting directory / starting command thing, but alas.

#+begin_src emacs-lisp
  (defun my/create-named-vterm ()
    "Prompt for a name, create a new vterm buffer called NAME-vterm, and open it."
    (interactive)
    (let* ((name      (read-string "Enter vterm name: "))
	   (buf-name  (concat name "-vterm")))
      (vterm buf-name)
      (switch-to-buffer buf-name)))
#+end_src

#+begin_src emacs-lisp
  (transient-define-prefix my/create-menu ()
			   "Create menu"
			   [["Create"
			     ("t" "terminal buffer" my/create-named-vterm)
			     ("g" "gptel buffer" my/create-named-gptel)
			     ("m" "memory" my/create-memory-interactive)
			     ("c" "Capture" org-capture)]])
#+end_src

** The "Execute" Menu

#+begin_src emacs-lisp
  (transient-define-prefix my/execute-menu ()
			   "Transient menu for executing actions in projects, files, buffers, etc."
			   ["Execute"
			    ("x" "Project Command" my/executer-picker)])
#+end_src

* Custom Keymaps
** General

#+begin_src emacs-lisp
  (define-prefix-command 'my-custom-prefix)
  (evil-define-key 'normal 'global (kbd "C-a") 'my-custom-prefix)
  (which-key-add-key-based-replacements "C-a" "my commands")

  ;; create "go" prefix map
  (define-prefix-command 'my-go-prefix)
  (evil-define-key 'normal 'global (kbd "C-a g") 'my-go-prefix)
  (which-key-add-key-based-replacements "C-a g" "go")

  (defun my/open-compilation-file-in-other-window ()
    "open the current compilation match in another window.
    creates a new window if needed or reuses an existing one."
    (interactive)
    (let ((window-count (length (window-list))))
      (condition-case err
	  (if (= window-count 1)
	      ;; only one window, use built-in function that creates a new window
	      (compilation-display-error)
	    ;; multiple windows exist, use the next window
	    (let ((this-window (selected-window)))
	      (other-window 1)
	      (let ((target-window (selected-window)))
		(select-window this-window)
		;; use next-error-no-select to get location without changing windows
		(let ((location (next-error-no-select)))
		  (select-window target-window)
		  (switch-to-buffer (marker-buffer (car location)))
		  (goto-char (marker-position (car location)))))))
	;; catch any errors silently
	(error (message "no valid location found at point")))))

  (evil-define-key 'normal 'global (kbd "C-a g f") 'my/open-compilation-file-in-other-window)
  (which-key-add-key-based-replacements "C-a g f" "go to file")

  (evil-define-key 'normal 'global (kbd "C-a g d") 'lsp-find-definition)
  (which-key-add-key-based-replacements "C-a g d" "go to definition")
  (which-key-add-key-based-replacements "C-a g e" "emacs config")

  (define-prefix-command 'my-compile-prefix)
  (evil-define-key 'normal 'global (kbd "C-a c") 'my-compile-prefix)
  (which-key-add-key-based-replacements "C-a c" "compile")

  (define-prefix-command 'my-nix-compile-prefix)
  (evil-define-key 'normal 'global (kbd "C-a c n") 'my-nix-compile-prefix)
  (which-key-add-key-based-replacements "C-a c n" "nix")

  (evil-define-key 'normal 'global (kbd "C-a c n r") 'my/nix-rebuild)
  (which-key-add-key-based-replacements "C-a c n r" "rebuild")

  (evil-define-key 'normal 'global (kbd "C-a c n f") 'my/nix-format)
  (which-key-add-key-based-replacements "C-a c n f" "format")

  (evil-define-key 'normal 'global (kbd "C-a c n c") 'my/nix-commit)
  (which-key-add-key-based-replacements "C-a c n c" "commit")

  ;; create "find" prefix map
  (define-prefix-command 'my-find-prefix)
  (evil-define-key 'normal 'global (kbd "C-a f") 'my-find-prefix)
  (which-key-add-key-based-replacements "C-a f" "find")

  (evil-define-key 'normal 'global (kbd "C-a f g") 'projectile-ripgrep)
  (which-key-add-key-based-replacements "C-a f g" "ripgrep")

  (evil-define-key 'normal 'global (kbd "C-a f p") 'projectile-switch-project)
  (which-key-add-key-based-replacements "C-a f p" "project")

  (evil-define-key 'normal 'global (kbd "C-a f f") 'find-file)
  (which-key-add-key-based-replacements "C-a f f" "file in directory")

  (evil-define-key 'normal 'global (kbd "C-a f F") 'projectile-find-file)
  (which-key-add-key-based-replacements "C-a f F" "file in project")

  (evil-define-key 'normal 'global (kbd "C-a f b") 'consult-buffer)
  (which-key-add-key-based-replacements "C-a f b" "find an open buffer")

  (evil-define-key 'normal 'global (kbd "U") 'undo-redo)

  (defun my/org-agenda-daily-dashboard ()
    "Open the custom 'daily dashboard' org-agenda view."
    (interactive)
    (org-agenda nil "d"))

  (evil-define-key 'normal 'global (kbd "D") 'kill-buffer)
  (evil-define-key 'normal magit-mode-map (kbd "C-d") 'kill-buffer)

  (evil-define-key 'normal 'global (kbd "C-e") 'elfeed)
  (evil-define-key 'normal elfeed-search-mode-map (kbd "C-r") 'elfeed-update)

  (evil-define-key 'normal 'global (kbd "<f6>") 'my/toggle-theme)
  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "<f6>") 'my/toggle-theme))

  (evil-define-key 'normal 'global (kbd "C-z") 'magit-status)

  (with-eval-after-load 'elfeed-show
    (require 'hnreader)
    (require 'evil)

    (defun my/elfeed-show-hn-comments ()
      "Open Hacker News comments for the link at point in elfeed-show-mode."
      (interactive)
      (message "my/elfeed-show-hn-comments invoked.")
      (let ((link (elfeed-get-link-at-point)))
	(message "Link at point: %s" link)
	;; Check if it's a valid HN item link
	(if (and link (string-match "news\\.ycombinator\\.com/item\\?id=[0-9]+" link))
	    (progn ;; Use progn to execute multiple forms
	      (message "Found HN link: %s. Calling hnreader-comment..." link)
	      ;; Pass the full link URL to hnreader-comment
	      (hnreader-comment link)
	      (message "hnreader-comment called with URL."))
	  (message "No Hacker News item link found at point or link doesn't match pattern."))))

    (evil-define-key 'normal elfeed-show-mode-map
		     (kbd "c") #'my/elfeed-show-hn-comments))

  (evil-global-set-key 'normal (kbd "C-p") 'projectile-switch-project)
  (evil-global-set-key 'normal (kbd "C-f") 'projectile-find-file)
  (evil-define-key 'normal magit-mode-map (kbd "C-p") 'projectile-switch-project)
  (evil-define-key 'normal magit-mode-map (kbd "C-f") 'projectile-find-file)
  (evil-define-key 'normal vterm-mode-map (kbd "C-p") 'projectile-switch-project)
  (evil-define-key 'normal vterm-mode-map (kbd "C-f") 'projectile-find-file)

  (defun my/projectile-find-file-in-all-projects ()
    "Find file across all registered Projectile projects with improved performance."
    (interactive)
    (let* ((projects (projectile-relevant-known-projects))
	   (file-cache-var 'my/projectile-all-files-cache)
	   (cache-validity-seconds 300) ;; 5 minute cache validity
	   (current-time (current-time))
	   (use-cache (and (boundp file-cache-var)
			   (< (float-time (time-subtract 
					   current-time
					   (get file-cache-var 'timestamp)))
			      cache-validity-seconds)))
	   (cached-files (and use-cache (symbol-value file-cache-var))))

      (if use-cache
	  (message "Using cached file list (%d files)" (length cached-files))
	;; Build cache using external commands for speed
	(message "Building file list from %d projects..." (length projects))
	(let ((all-files '())
	      (temp-file (make-temp-file "projectile-files-")))
	  ;; Using external find/sort is much faster than pure elisp
	  (with-temp-file temp-file
	    (dolist (project projects)
	      (when (file-exists-p project)
		(let* ((project-name (file-name-nondirectory 
				      (directory-file-name project)))
		       ;; Add project name prefix to each file for context
		       (cmd (format "cd %s && find . -type f -not -path \"*/\\.*\" | sort | sed 's|^\\.|%s:|'"
				    (shell-quote-argument project)
				    project-name)))
		  (call-process-shell-command cmd nil t)))))

	  ;; Read results back and build alist of (display . filepath)
	  (with-temp-buffer
	    (insert-file-contents temp-file)
	    (goto-char (point-min))
	    (while (not (eobp))
	      (let* ((line (buffer-substring-no-properties (point) (line-end-position)))
		     ;; Fix: Only split on the first colon
		     (split-pos (string-match ":" line))
		     (project-name (when split-pos (substring line 0 split-pos)))
		     (rel-file (when split-pos (substring line (1+ split-pos))))
		     (full-path (when (and project-name rel-file)
				  (expand-file-name
				   (string-remove-prefix "./" rel-file)
				   (car (seq-filter (lambda (p) 
						      (string-suffix-p project-name p))
						    projects))))))
		(when (and project-name rel-file full-path)
		  (push (cons (concat project-name ":" rel-file) full-path) all-files)))
	      (forward-line 1)))

	  (delete-file temp-file)
	  ;; Save and timestamp the cache
	  (set file-cache-var all-files)
	  (put file-cache-var 'timestamp current-time)
	  (message "Found %d files across projects" (length all-files))))

      ;; Use the cached or newly-built list
      (let ((file-list (if use-cache cached-files (symbol-value file-cache-var))))
	(if file-list
	    ;; Use completing-read for the selection interface
	    (let* ((chosen (completing-read "Find file in projects: " 
					    (mapcar #'car file-list) nil t))
		   (file-path (cdr (assoc chosen file-list))))
	      (when file-path
		(find-file file-path)))
	  (message "No files found across projects")))))

  (defun my/open-pr-url-at-point ()
    "Open the PR_URL property of the current org agenda item."
    (interactive)
    (let* ((marker (or (org-get-at-bol 'org-marker)
		       (org-agenda-error)))
	   (buffer (marker-buffer marker))
	   (pos (marker-position marker))
	   url)
      (with-current-buffer buffer
	(save-excursion
	  (goto-char pos)
	  (setq url (org-entry-get (point) "PR_URL"))))
      (when url
	(browse-url url))))
#+end_src
#+RESULTS:

** Launching Transient Menus
#+begin_src emacs-lisp
  (evil-define-key 'normal 'global (kbd "C-g") #'my/go-menu)
  (evil-define-key '(normal insert) 'global (kbd "C-<return>") #'my/insert-menu)
  (evil-define-key 'normal 'global (kbd "C-s") #'my/search-menu)
  (evil-define-key 'normal 'global (kbd "C-l") 'gptel-menu)
  (evil-define-key 'normal 'global (kbd "C-b") #'my/create-menu)
  (evil-define-key 'normal 'global (kbd "C-x") #'my/execute-menu)
#+end_src
** Mode Specific

These are usually called from a mode init hook

*** Cominit Mode Keymaps

#+begin_src emacs-lisp
  (defun my/cominit-mode-set-keybindings ()
    (interactive)
    "Sets all my cominit mode specific keybindings"
    (local-set-key (kbd "C-b") #'my/create-menu)
    (local-set-key (kbd "C-g") #'my/go-menu)
    (local-set-key (kbd "C-<return>") #'my/insert-menu)
    (local-set-key (kbd "C-s") #'my/search-menu)
    (local-set-key (kbd "C-x") #'my/execute-menu)

    (evil-define-key '(normal visual motion) magit-status-mode-map
		     (kbd "C-g") #'my/go-menu
		     (kbd "C-<return>") #'my/insert-menu
		     (kbd "C-s") #'my/search-menu
		     (kbd "C-x") #'my/execute-menu
		     (kbd "C-b") #'my/create-menu)
    )
#+end_src

*** Org Mode Keymaps

#+begin_src emacs-lisp
  (defun my/org-mode-set-keybindings ()
    (interactive)
    "Sets all my org mode specific keybindings"
    (evil-define-key 'operator org-mode-map (kbd "is") 'evil-inner-org-src-block)
    (evil-define-key 'normal org-mode-map (kbd "<backtab>") 'org-cycle-global)
    (evil-define-key 'operator org-mode-map (kbd "as") 'evil-a-org-src-block))
#+end_src

*** Org Agenda Keymaps

Using evil-mode based mappings don't work on the agenda, for same reason

#+begin_src emacs-lisp
  (defun my/org-agenda-mode-set-keybindings ()
    (interactive)
    "Sets all my org mode specific keybindings"
    ;; Using local-set-key ensures the binding takes precedence in the current buffer
    (local-set-key (kbd "C-b") #'my/create-menu)
    (local-set-key (kbd "C-g") #'my/go-menu)
    (local-set-key (kbd "C-<return>") #'my/insert-menu)
    (local-set-key (kbd "C-s") #'my/search-menu)
    (local-set-key (kbd "C-x") #'my/execute-menu)

    ;; Also set the evil motion state map as a backup approach
    (evil-define-key '(normal visual motion) org-agenda-mode-map
		     (kbd "C-g") #'my/go-menu
		     (kbd "C-s") #'my/search-menu
		     (kbd "C-x") #'my/execute-menu
		     (kbd "C-b") #'my/create-menu))
#+end_src

*** Magit Status Keymaps

Using evil-mode based mappings don't work on the agenda, for same reason

#+begin_src emacs-lisp
  (defun my/magit-status-mode-set-keybindings ()
    (interactive)
    "Sets all my magit-status mode specific keybindings"
    ;; Using local-set-key ensures the binding takes precedence in the current buffer
    (local-set-key (kbd "C-b") #'my/create-menu)
    (local-set-key (kbd "C-g") #'my/go-menu)
    (local-set-key (kbd "C-<return>") #'my/insert-menu)
    (local-set-key (kbd "C-s") #'my/search-menu)
    (local-set-key (kbd "C-x") #'my/execute-menu)

    ;; Also set the evil motion state map as a backup approach
    (evil-define-key '(normal visual motion) magit-status-mode-map
		     (kbd "C-g") #'my/go-menu
		     (kbd "C-<return>") #'my/insert-menu
		     (kbd "C-s") #'my/search-menu
		     (kbd "C-x") #'my/execute-menu
		     (kbd "C-b") #'my/create-menu)
    )
#+end_src

*** Gptel Mode Keymaps
#+begin_src emacs-lisp :tangle no
  (defun my/gptel-mode-set-keybindings ()
    (interactive)
    "Sets all my gptel mode specific keybindings"
    )
#+end_src

* Mode Init Hooks
** Cominit Init Hook

#+begin_src emacs-lisp :tangle no
  (defun cominit-mode-init ()
    "Function to run on cominit mode init"
    (my/cominit-mode-set-keybindings))
  (add-hook cominit-mode-hook #'cominit-mode-init)
#+end_src

** Org Mode Init Hook

#+begin_src emacs-lisp
  (defun org-mode-init ()
    "Function to run on org mode init"
    (org-display-inline-images)
    (variable-pitch-mode)
    (breadcrumb-local-mode)
    (org-indent-mode)
    ;; I want to like you org-modern, I really do.
    ;;(org-modern-mode)
    (setq-local line-spacing 0.5)
    (my/toggle-olivetti)
    (my/org-mode-set-keybindings))
  (add-hook 'org-mode-hook #'org-mode-init)
#+end_src

** Org Agenda Mode Init Hook

#+begin_src emacs-lisp
  (defun org-agenda-mode-init ()
    "Function to run on org agenda mode init"
    (variable-pitch-mode)
    (my/org-agenda-mode-set-keybindings)
    (my/toggle-olivetti))
  (add-hook 'org-agenda-mode-hook #'org-agenda-mode-init)
#+end_src

** Olivetti Mode Init Hook

#+begin_src emacs-lisp :tangle no
  (defun my/olivetti-mode-init ()
    (my/update-olivetti-fringe-face))
  (add-hook 'olivetti-mode-hook 'my/olivetti-mode-init)
#+end_src

** Gptel Mode

#+begin_src emacs-lisp :tangle no
  (defun gptel-mode-init ()
    "Function to run on gptel mode init"
    (my/gptel-mode-set-keybindings))
  (add-hook 'gptel-mode-hook #'gptel-mode-init)
#+end_src

** Magit Status Mode

#+begin_src emacs-lisp
  (defun magit-status-mode-init ()
    "Function to run on magit status mode init"
    (my/magit-status-mode-set-keybindings)
    (my/toggle-olivetti))
  (add-hook 'magit-status-mode-hook #'magit-status-mode-init)
#+end_src

* Final Function Advice
** Update Olivetti Fringes on Theme Toggle
#+begin_src emacs-lisp
  (advice-add 'my/toggle-theme :after 'my/update-olivetti-fringe-face)
#+end_src
* Sending Stuff To My Kindle
#+begin_src emacs-lisp
(defun my/wikipedia-search (search-term)
  "Prompt for SEARCH-TERM, select an article using consult, and return its URL."
  (interactive "sSearch Wikipedia for: ")
  (let* ((search-url (format "https://en.wikipedia.org/w/api.php?action=opensearch&search=%s&limit=15&namespace=0&format=json"
                             (url-hexify-string search-term)))
         (buffer (url-retrieve-synchronously search-url t t 5))
         articles result-alist selected)
    (unless buffer (error "Failed to fetch Wikipedia results"))
    (with-current-buffer buffer
      (goto-char (point-min))
      (re-search-forward "^$" nil t) 
      (let* ((json-array-type 'list)   
             (json-object-type 'alist) 
             (json-data (json-read))
             (titles (nth 1 json-data))
             (desc   (nth 2 json-data))
             (urls   (nth 3 json-data)))
        (setq articles
              (cl-mapcar (lambda (title desc url)
                           (cons (format "%s â€” %s" title url) url))
                         titles desc urls))))
    (kill-buffer buffer)
    (setq result-alist articles)
    (setq selected (consult--read (mapcar #'car result-alist)
                                  :prompt "Pick article: "
                                  :require-match t))
    (let ((url (cdr (assoc selected result-alist))))
      (when (called-interactively-p 'any)
        (when url (browse-url url)))
      url)))

(defun my/wikipedia-send-to-kindle ()
  "Prompt for a Wikipedia search, select an article, and send its URL to Kindle."
  (interactive)
  (let* ((search-term (read-string "Search Wikipedia for: "))
         (url (my/wikipedia-search search-term))
         (compilation-buffer-name-function
          (lambda (_mode)
            (format "*wikipedia-to-kindle-%s*" (or search-term "search")))))
    (when url
      (compile (format "sudo wikipedia-to-kindle-generate %s" (shell-quote-argument url)) t))))
#+end_src

#+begin_src emacs-lisp
(defun my/cookbook-to-kindle-generate ()
  "Generate and send the Org-roam cookbook EPUB to Kindle, running in a compilation buffer."
  (interactive)
  (let ((cmd "cookbook-to-kindle-generate"))
    (let ((compilation-buffer-name-function (lambda (_mode) "*cookbook-to-kindle*")))
      (compile (format "sudo %s" cmd) t))))
#+end_src

#+begin_src emacs-lisp
(defun my/memory-to-kindle-send (&optional id)
  "Prompt for an Org-roam node (or use current buffer) and send it to Kindle."
  (interactive)
  (let* ((node-id (or id
                      (when (and (fboundp 'org-roam-id-at-point)
                                 (org-roam-id-at-point))
                        (org-roam-id-at-point))
                      (when (fboundp 'org-roam-node-read)
                        (org-roam-node-id (org-roam-node-read))))))
    (unless node-id (user-error "No Org-roam ID available"))
    (let ((compilation-buffer-name-function (lambda (_mode) "*memory-to-kindle*")))
      (compile (format "sudo memory-to-kindle-generate %s"
                       (shell-quote-argument node-id))
               t))))

(defun my/current-org-file-to-kindle ()
  "Send the current Org file to Kindle by path."
  (interactive)
  (unless buffer-file-name (user-error "Not visiting a file"))
  (when (buffer-modified-p) (save-buffer))
  (let ((compilation-buffer-name-function (lambda (_mode) "*memory-to-kindle*")))
    (compile (format "sudo memory-to-kindle-generate %s"
                     (shell-quote-argument (file-truename buffer-file-name)))
             t)))
#+end_src

* Provide Init

#+begin_src emacs-lisp
  (provide 'init)

  ;; Local Variables:
  ;; byte-compile-warnings: (not free-vars)
  ;; End:
		      ;;; init.el ends here
#+end_src
