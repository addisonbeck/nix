#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle init.el :results none

* Bootstrap
#+begin_src emacs-lisp
  ;; init.el --- My personal Emacs configuration  -*- lexical-binding: t -*-

  ;; Commentary:
  ;; This is my personal Emacs configuration file.
  ;; It sets up various packages and configurations for development work.

  ;; Code:
#+end_src

* Setup Global Variable

Here I'll define some key data structures used throughout the rest of the configuration

** Projects

*** The Projects Data Structure

#+begin_src emacs-lisp
  (defvar my/projects
    '(("nix"       . (:path "~/nix"))
      ("notes" . (:path "~/notes"))
      ("clients" . (:path "~/bitwarden/clients"))
      ("server" . (:path "~/bitwarden/server"))
      ("sdk-internal" . (:path "~/bitwarden/sdk-internal"))
      ("nx-poc"    . (:path "~/bitwarden/bitwarden-nx-poc"))
      ("wg-open-source" . (:path "~/bitwarden/wg-open-source-at-bitwarden"))
      ("binwarden" . (:path "~/binwarden"))
      ("d" . (:path "~/d"))
      ("contributing-docs" . (:path "~/bitwarden/contributing-docs")))
    "Alist of projects with metadata")
#+end_src

#+RESULTS:
: my/projects

*** Project Functions

#+begin_src emacs-lisp
  (defun my/get-project-attr (project-name attr)
    "Get ATTR for PROJECT-NAME."
    (plist-get (alist-get project-name my/projects nil nil #'string=) attr))

  (defun my/get-project-path (project-name)
    "Get the path for PROJECT-NAME."
    (my/get-project-attr project-name :path))

  (defun my/find-project (project-name)
    "Open a project's root directory."
    (interactive
     (list (completing-read "Project: " (mapcar #'car my/projects))))
    (find-file (my/get-project-path project-name)))

  (defun my/project-dired ()
    "Open dired in a project directory."
    (interactive)
    (let ((project-name (completing-read "Project: " (mapcar #'car my/projects))))
      (dired (my/get-project-path project-name))))

  (defun my/compile-in-project (project-name command)
    "Run compilation COMMAND in PROJECT-NAME."
    (interactive
     (let* ((project (completing-read "Project: " (mapcar #'car my/projects)))
	    (command (read-string "Command: " nil 'compile-history)))
       (list project command)))
    (let* ((default-directory (my/get-project-path project-name))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*compile-%s*" project-name))))
      (compile command t)))

  (defun my/terminal-in-project ()
    "Open terminal in a project directory."
    (interactive)
    (let* ((project-name (completing-read "Project: " (mapcar #'car my/projects)))
	   (default-directory (my/get-project-path project-name)))
      (vterm (format "*vterm-%s*" project-name))))
#+end_src

#+RESULTS:
: my/terminal-in-project

* Initialize Package Sources
#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			   ("org" . "https://orgmode.org/elpa/")
			   ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Initialize use-package
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* UI Configuration

#+begin_src emacs-lisp
  ;; Configure frame appearance
  (setq default-frame-alist
	'((menu-bar-lines . 0)
	  (tool-bar-lines . 0)
	  (vertical-scroll-bars)
	  (left-fringe . 0)
	  (right-fringe . 0)
	  (internal-border-width . 0)
	  (undecorated . t)
	  (fullscreen . maximized)))

  (setq inhibit-startup-message t)
  (setq initial-frame-alist default-frame-alist)

  (advice-add #'display-startup-echo-area-message :override #'ignore)

  (defun my/current-project-name ()
    "Get the name of the current project from my/projects if there is one."
    (when-let* ((file-path (buffer-file-name))
		(abs-path (expand-file-name file-path)))
      (catch 'found
	(dolist (project my/projects)
	  (let* ((project-name (car project))
		 (project-path (expand-file-name (my/get-project-path project-name))))
	    (when (string-prefix-p project-path abs-path)
	      (throw 'found project-name))))
	nil)))

  (setq-default mode-line-format
		(list
		 ;; Current project (if any)
		 '(:eval (when-let ((project (my/current-project-name)))
			   (propertize (format "%s/" project) 'face 'mode-line-emphasis)))
		 ;; Filename
		 '(:eval (propertize "%b " 'face 'mode-line-buffer-id))
		 ;; Major mode
		 '(:eval (propertize (format " %s " major-mode) 'face 'mode-line-buffer-id))
		 ;; Git branch and status using vc-mode
		 '(:eval (when vc-mode
			   (let ((branch (replace-regexp-in-string "^ Git[:-]" "" vc-mode)))
			     (concat
			      (propertize " " 'face 'buffer-file-name)
			      (propertize (format "%s" branch) 'face 'mode-line-emphasis)
			      (propertize (if (vc-state buffer-file-name) " ++" "") 'face
					  (if (vc-state buffer-file-name) 'error 'success))
			      (propertize " " 'face 'buffer-file-name)))))
		 ))
#+end_src

* Basic Settings
#+begin_src emacs-lisp
  ;; Disable backup files and configure indentation
  (setq make-backup-files nil)
  (setq-default indent-tabs-mode nil)
  (electric-indent-mode 1)
  (setq-default tab-width 2
		indent-tabs-mode nil
		tab-stop-list (number-sequence 2 120 2))
  (setq confirm-kill-emacs nil)
  (setq auto-save-default nil
	create-lockfiles nil)
  (setq select-enable-clipboard t)
  (setq case-fold-search t)
  (xterm-mouse-mode 1)
  (setq-default fill-column 77)
  (global-hl-line-mode -1)
  (setq sentence-end-double-space nil)
#+end_src

* Buffer Management Functions
#+begin_src emacs-lisp
  (defun kill-other-buffers ()
    "Kill all buffers except the current one."
    (interactive)
    (mapc 'kill-buffer
	  (delq (current-buffer)
		(buffer-list))))

  (defun my/delete-this-file ()
    "Delete the current file and kill its buffer."
    (interactive)
    (let ((file (buffer-file-name)))
      (when (and file
		 (y-or-n-p (format "Delete %s?" file)))
	(delete-file file)
	(kill-buffer)
	(message "Deleted %s" file))))
#+end_src

* Package Management
#+begin_src emacs-lisp
  (require 'package)

  ;; Use Package Configuration
  (use-package nerd-icons)

  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (when (daemonp)
    (exec-path-from-shell-initialize))
#+end_src

* Dashboard Configuration
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :init
    (setq dashboard-icon-type 'nerd-icons)
    (setq dashboard-projects-backend 'projectile)
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-center-content t
	  dashboard-items '((recents . 5)
			    (projects . 5)
			    (bookmarks . 5))
	  dashboard-set-heading-icons t
	  dashboard-set-file-icons t
	  dashboard-show-shortcuts t)
    (setq dashboard-heading-icons '((recents   . "nf-oct-history")
				    (bookmarks . "nf-oct-bookmark")
				    (projects  . "nf-oct-project"))))
#+end_src

* Font Configuration
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :family "Iosevka" :height 140)
  (set-face-attribute 'variable-pitch nil :family "Iosevka Etoile" :height 100)
#+end_src

* Evil Mode Configuration
#+begin_src emacs-lisp
  ;; Test
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)

  (use-package evil
    :ensure t
    :config
    (evil-mode 1)

    ;; Custom movement functions
    (defun evil-move-half-page-down ()
      "Move cursor half page down"
      (interactive)
      (evil-next-line (/ (window-height) 4))
      (evil-scroll-line-to-center nil))

    (defun evil-move-half-page-up ()
      "Move cursor half page up"
      (interactive)
      (evil-previous-line (/ (window-height) 4))
      (evil-scroll-line-to-center nil))

    ;; Bind J and K to half-page movement
    (define-key evil-normal-state-map (kbd "J") 'evil-move-half-page-down)
    (define-key evil-normal-state-map (kbd "K") 'evil-move-half-page-up))

  (use-package evil-collection
    :ensure t
    :after evil
    :config
    (evil-collection-init))

  ;; Configure evil-collection for magit
  (with-eval-after-load 'evil-collection-magit
    (evil-collection-define-key 'normal 'magit-status-mode-map
				"V" #'magit-start-region-select))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  (evil-define-key 'motion org-agenda-mode-map
		   (kbd "C-b") 'projectile-switch-to-buffer
		   (kbd "C-p") 'projectile-switch-project
		   (kbd "C-f") 'projectile-find-file
		   (kbd "<left>") 'org-agenda-earlier
		   (kbd "<right>") 'org-agenda-later
		   (kbd "C-c j") 'org-agenda-goto-date
		   (kbd "gx")  'org-agenda-open-link
		   (kbd "t") 'org-agenda-todo
		   (kbd "T") 'org-agenda-todo-yesterday)
#+end_src

* Cycle Line Number Function
#+begin_src emacs-lisp
  (defun cycle-line-numbers ()
    "Cycle through line number modes: off -> relative -> normal -> off."
    (interactive)
    (cond
     ;; If currently off, switch to relative
     ((not display-line-numbers)
      (setq display-line-numbers 'relative)
      (message "Line numbers: RELATIVE"))

     ;; If currently relative, switch to normal
     ((eq display-line-numbers 'relative)
      (setq display-line-numbers t)
      (message "Line numbers: NORMAL"))

     ;; If currently normal, switch to off
     (t
      (setq display-line-numbers nil)
      (message "Line numbers: OFF"))))

  ;; Bind to "N" in evil normal mode
  (with-eval-after-load 'evil
    (evil-define-key 'normal 'global "N" 'cycle-line-numbers))
#+end_src
* Server Configuration
#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

* Project Management
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (define-key projectile-command-map (kbd "d") 'projectile-find-file-in-directory)
    (define-key projectile-command-map (kbd "P") 'my/projectile-find-file-in-all-projects)
    (setq projectile-indexing-method 'alien)
    (setq projectile-git-command "git ls-files -zco -X ~/.gitignore")
    (setq projectile-known-projects
	  (mapcar (lambda (project)
		    (expand-file-name (my/get-project-path (car project))))
		  my/projects))
    (setq projectile-auto-discover nil)
    (projectile-save-known-projects)
    :bind-keymap
    ("C-c p" . projectile-command-map))
#+end_src

* Completion Framework
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles . (partial-completion))))))

  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))

  (use-package consult
    :ensure t
    :bind
    (("C-s" . consult-line)
     ("C-c b" . consult-buffer)
     ("C-c f" . consult-find)
     ("C-c r" . consult-ripgrep)))

  ;; Custom find-from-here function
  (defun find-from-here ()
    "Find files from current buffer's directory."
    (interactive)
    (when buffer-file-name
      (consult-find (file-name-directory buffer-file-name))))

  (global-set-key (kbd "C-c d") 'find-from-here)
#+end_src

* Tree-sitter Configuration
#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :config
    (global-treesit-auto-mode)
    (setq treesit-auto-install 'prompt)
    (setq treesit-auto-langs '(typescript javascript tsx jsx)))

  (use-package typescript-ts-mode
    :ensure t
    :mode (("\\.ts\\'" . typescript-ts-mode)
	   ("\\.tsx\\'" . tsx-ts-mode))
    :init
    (add-to-list 'major-mode-remap-alist '(typescript-mode . typescript-ts-mode))
    (add-to-list 'major-mode-remap-alist '(tsx-mode . tsx-ts-mode)))

  ;; Ensure typescript grammar is installed
  (unless (treesit-language-available-p 'typescript)
    (treesit-install-language-grammar 'typescript))
#+end_src

* LSP Configuration
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :hook ((typescript-ts-mode . lsp)
	   (tsx-ts-mode . lsp)
	   (typescript-mode . lsp)
	   (csharp-mode . lsp)
	   (rust-mode . lsp)
	   (nix-mode . lsp)
	   (json-mode . lsp)
	   (sql-mode . lsp)
	   (lua-mode . lsp))
    :commands lsp
    :config
    ;;(setq lsp-nix-nixd-server-path "nixd")
    ;;(setq lsp-enabled-clients '(nixd-lsp))
    (setq lsp-auto-guess-root t)
    (setq lsp-enable-symbol-highlighting t)
    (setq lsp-enable-on-type-formatting t)
    (setq lsp-modeline-code-actions-enable t)
    (setq lsp-modeline-diagnostics-enable t)
    (setq lsp-diagnostics-provider :flycheck)
    (setq lsp-ui-doc-enable t)
    (setq lsp-ui-doc-show-with-cursor t)
    (add-to-list 'lsp-disabled-clients 'copilot-ls)
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\chats\\'")
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-headerline-breadcrumb-mode nil)
    (lsp-enable-which-key-integration t))

  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode)

  ;; Company mode for completions
  (use-package company
    :ensure t
    :config
    (setq company-minimum-prefix-length 1
	  company-idle-delay 0.0))

  ;; Add flycheck configuration
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode))
#+end_src

* Magit and Forge Configuration
#+begin_src emacs-lisp
  (defun magit-status-project ()
    "Switch project and open magit."
    (interactive)
    (let ((projectile-switch-project-action 'magit-status))
      (projectile-switch-project)))

  (global-set-key (kbd "C-c m") 'magit-status-project)

  (use-package forge
    :ensure t
    :after magit
    :config
    ;; Configure GitHub authentication
    (setq auth-sources '("~/.authinfo"))
    ;; Optionally set the number of items to fetch
    (setq forge-topic-list-limit '(60 . 0)))
#+end_src

* Basic Settings and Markdown Configuration
#+begin_src emacs-lisp
  ;; Basic settings
  (setq notes-directory "~/notes")
  (setq markdown-command "pandoc")

  ;; Markdown configuration
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode)))
#+end_src

* Org Mode Configuration 
#+begin_src emacs-lisp
  ;; Basic org settings
  (use-package org
    :ensure t
    :bind
    (("C-c a" . org-agenda)
     ("C-c h" . consult-org-heading)
     ("C-c c" . org-capture))
    :config
    (setq org-directory "~/notes")
    (setq org-startup-truncated nil)
    (setq org-agenda-files (list org-directory))
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-startup-folded 'overview)
    (setq org-auto-align-tags nil)
    (setq org-clock-persist 'history
	  org-export-backends '(html icalendar latex man md org json)
	  org-image-max-width 'window
	  org-startup-with-inline-images t
	  org-cycle-inline-images-display t
	  org-display-remote-inline-images 'download
	  org-clock-idle-time 15
	  org-clock-persist-file "~/notes/clock.el"
	  org-clock-auto-clock-resolution 'when-no-clock-is-running
	  org-clock-report-include-clocking-task t
	  org-clock-into-drawer t)
    (org-clock-persistence-insinuate))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (org . t)
     (mermaid . t)
     ))

  (setq org-babel-sh-command "bash -l -c")

  (setenv "PUPPETEER_EXECUTABLE_PATH" 
	  (or (executable-find "google-chrome-stable")
	      (executable-find "google-chrome")))

  (setq org-src-preserve-indentation nil
	org-edit-src-content-indentation 0)

  (require 'ox-json)

  (use-package ob-mermaid
    :config
    ;; Set the path to the mermaid CLI using the custom puppeteer-cli
    (setq ob-mermaid-cli-path (executable-find "mmdc"))
    ;; If you need to specify the Chrome executable directly:
    (setq ob-mermaid-browser-path (executable-find "google-chrome-stable")))

  ;; Enable automatic display of inline images after executing babel blocks
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
  (setq org-redisplay-inline-images t)

  ;; Allow evaluation of code blocks without confirmation for safe languages
  (defun my/org-confirm-babel-evaluate (lang body)
    (not (member lang '("emacs-lisp" "shell"))))
  ;;(setq org-confirm-babel-evaluate 'my/org-confirm-babel-evaluate)
  (setq org-confirm-babel-evaluate nil)

  ;; Ensure pretty fontification of source blocks
  (setq org-src-fontify-natively t)
  (define-key org-mode-map (kbd "RET") 'newline)

  ;; These bindings just emulate the defaults instead of doing a bunch of weird org specific stuff.
  (evil-define-key 'insert org-mode-map (kbd "RET") 'newline)
  (evil-define-key 'insert org-mode-map (kbd "TAB") 'tab-to-tab-stop)
  (defun my-org-evil-open-below ()
    "Open line below preserving org structure but preventing reformatting."
    (interactive)
    ;; Use evil's basic open behavior
    (evil-open-below 1)
    ;; Exit insert state then re-enter to avoid auto-formatting
    (evil-normal-state)
    (evil-insert-state))

  (evil-define-key 'normal org-mode-map "o" 'my-org-evil-open-below)

  ;;(require 'ob-async) ;; Allow for asyncround running of babel blocks

  ;; Custom keybinding for executing all source blocks in a subtree
  (define-key org-mode-map (kbd "C-c C-v C-t") 'org-babel-execute-subtree)

  (require 'org-make-toc)
#+end_src

For some reason this keeps getting set wrong by something.

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-directory))
#+end_src

* Org To Jira
#+begin_src emacs-lisp :tangle no
  (use-package ox-jira
    :ensure t
    :after org)
#+end_src
* Org Capture Templates and Functions
#+begin_src emacs-lisp
  (setq org-capture-templates
	'(
	  ("l" "Log" entry
	   (file "~/notes/inbox.org")
	   "* %U %^{Title}\n%?")
	  ("e" "Event" entry
	   (file "~/notes/inbox.org")
	   "* %^{Title}\n%^T{Date and Time}\n%?")
	  ("t" "Todo" entry
	   (file "~/notes/inbox.org")
	   "* TODO %^{Title}\nSCHEDULED: %t\n%?")
	  ))
#+end_src

* Date Tracking Functions

I'm not using these right now, but might revist in the future.

#+begin_src emacs-lisp :tangle no
  ;; Date tracking functions
  (defun my/org-set-completed-date ()
    (when (equal "Done" (org-entry-get nil "STATUS"))
      (org-entry-put nil "COMPLETED"
		     (format-time-string "[%Y-%m-%d %a]"))))

  (defun my/org-set-started-date ()
    (when (equal "In-Progress" (org-entry-get nil "STATUS"))
      (org-entry-put nil "STARTED"
		     (format-time-string "[%Y-%m-%d %a]"))))

  (add-hook 'org-property-changed-functions
	    (lambda (property value)
	      (when (equal property "STATUS")
		(my/org-set-completed-date)
		(my/org-set-started-date))))
#+end_src

* Conversion Functions
#+begin_src emacs-lisp
  (defun convert-to-org ()
    "Convert current markdown buffer to org format."
    (interactive)
    (let* ((md-file (buffer-file-name))
	   (org-file (concat (file-name-sans-extension md-file) ".org")))
      (when (and md-file (file-exists-p md-file))
	(call-process "pandoc" nil nil nil
		      "-f" "markdown"
		      "-t" "org"
		      md-file
		      "-o" org-file)
	(find-file org-file))))

  (defun convert-to-markdown ()
    "Convert current org buffer to markdown format."
    (interactive)
    (let* ((org-file (buffer-file-name))
	   (md-file (concat (file-name-sans-extension org-file) ".md")))
      (when (and org-file (file-exists-p org-file))
	(call-process "pandoc" nil nil nil
		      "-f" "org"
		      "-t" "markdown"
		      org-file
		      "-o" md-file)
	(find-file md-file))))

  (with-eval-after-load 'markdown-mode
    (define-key markdown-mode-map (kbd "C-c C-o") 'convert-to-org))

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c C-m") 'convert-to-markdown))

  (defun my/move-to-custom-id-file ()
    "Move selected org item to a new file named after its CUSTOM_ID property."
    (interactive)
    (save-excursion
      (let* ((region-content (buffer-substring (region-beginning) (region-end)))
	     (custom-id (save-excursion
			  (goto-char (region-beginning))
			  (org-entry-get nil "CUSTOM_ID"))))
	(if custom-id
	    (let ((new-file (concat "~/notes/" custom-id ".org")))
	      (with-temp-file new-file
		(insert "#+TITLE: " custom-id "\n\n")
		(insert region-content))
	      (delete-region (region-beginning) (region-end))
	      (insert (format "[[file:%s][%s]]\n" new-file custom-id))
	      (message "Moved to %s" new-file))
	  (message "No CUSTOM_ID property found!")))))
#+end_src

* Agenda Configuration
#+begin_src emacs-lisp
(setq org-agenda-block-separator nil)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-timegrid-use-ampm t)
(setq org-agenda-time-leading-zero t)
(setq org-agenda-todo-keyword-format "%s")
(setq org-agenda-include-diary t)
(setq org-refile-targets '((nil :maxlevel . 8)
		     (org-agenda-files :maxlevel . 2)))
(setq org-agenda-hide-tags-regexp ".")

;; Allow creating new nodes (including new files) when refiling
(setq org-refile-allow-creating-parent-nodes 'confirm)

;; Use the full outline paths for refile targets
(setq org-refile-use-outline-path nil)

;; Completes in steps so you can select a heading after selecting the file
(setq org-outline-path-complete-in-steps nil)

(require 'diary-lib)

(use-package org-super-agenda
  :after org-agenda
  :config
  (setq org-super-agenda-header-map nil)  
  (setq org-super-agenda-header-properties nil)
  (org-super-agenda-mode))

(setq warning-suppress-types '((org-element)))

(defun my/inherit-meeting-times ()
  "Set SCHEDULED property on meeting note TODOs based on parent timestamp."
  (interactive)
  (org-map-entries
   (lambda ()
     (when (and (string= (org-entry-get nil "CATEGORY") "meeting-notes")
	  (org-get-todo-state))
 (let ((timestamp nil))
   (save-excursion
     (when (org-up-heading-safe)
       (setq timestamp (org-entry-get nil "TIMESTAMP" t))))
   (when timestamp
     (org-schedule nil timestamp)))))
   "+CATEGORY=\"meeting-notes\"+TODO=\"TODO\""))

(setq org-agenda-custom-commands
'(("d" "daily dashboard"
   (
    (tags "+CATEGORY=\"inbox\"" 
	  ((org-agenda-overriding-header "Inbox")))
    (agenda "Schedule and Habits"
	    ((org-agenda-span 'day)
	     (org-agenda-sorting-strategy '((agenda time-up todo-state-down alpha-up)))
	     (org-agenda-overriding-header " ")
	     (org-super-agenda-groups
	      '(
		(:name "Happening today" 
		       :and(:scheduled nil :deadline nil :not(:time-grid t)))
		(:name "Today's Meeting Notes" :category "meeting-notes")
		(:name "Today's Schedule"
		       :time-grid t)
		(:name "Overdue" :deadline past)
		(:name "Due Today" :deadline today)
		(:name "High Priority" :priority "A")
		(:name "Code Review Queue" :category "code review")
		(:name "Code Review Bunker" :category "code review bunker")
		(:name "Active Bugs" :category "bug")
		(:name "Active Epics" :category "epic")
    (:name "Easy" :tag ("easy"))
    ;; I moved TODOs to a tags component because agenda won't show none todo/event items like logs
		;;(:name "Inbox" :category "inbox")
		(:name "Due Soon" :deadline future)
		(:name "Poetry" :category "my poems")
		(:name "Family Stuff" :category "family")
		(:name "Holidays" :category "holiday")
		(:name "The Garden" :category "the-garden")
		(:name "Logs" :category "log")
		(:name "Re: Me" :category "me")
		(:name "Re: Emily" :category "emily")
		(:name "Re: Lincoln" :category "lincoln")
		(:name "Re: Nora" :category "nora")
		(:name "Re: Fern" :category "fern")
		(:name "Re: Harry" :category "harry")
		(:name "AM Habits" :category "personal habits am")
		(:name "Midday Habits" :category "personal habits midday")
		(:name "PM Habits" :category "personal habits pm")
		(:name "Any Time Habits" :category "personal habits any time")
		(:name "Work Habits" :category "work habits")
		(:auto-category t)
		))))))
  ("w" "Weekly overview with super-agenda"
   ((agenda ""
	    ((org-agenda-span 7)                      ;; Show 7 days
	     (org-agenda-start-on-weekday nil)        ;; Start from current day
	     (org-agenda-time-grid '((daily today require-timed)
				     (800 1000 1200 1400 1600 1800 2000)
				     "......" "----------------"))  ;; Time grid config
	     (org-agenda-include-deadlines nil)       ;; No deadlines
	     (org-agenda-skip-scheduled-if-done t)     
	     (org-agenda-skip-deadline-if-done t)
	     (org-agenda-skip-scheduled-delay-if-done t)
	     (org-agenda-skip-function                ;; Skip scheduled items
	      '(org-agenda-skip-entry-if 'scheduled 'deadline))
	     (org-agenda-prefix-format '((agenda . "%?-12t ")))  ;; Only show time
	     (org-agenda-todo-keyword-format "")
	     (org-agenda-show-all-dates t)
	     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
	     (org-agenda-format-date "%A %Y-%m-%d")
	     ;; Super agenda groups
	     (org-super-agenda-groups
	      '(
		(:name "Happening today" 
		       :and(:scheduled nil :deadline nil :not(:time-grid t)))
		(:name "Today's Schedule"
		       :time-grid t)
		))))))
  ))

(setq org-agenda-time-grid-use-ampm t)
(setq org-agenda-with-times t)
(setq org-agenda-time-format "%I:%M%p")
(setq org-agenda-prefix-format
'((agenda . " ○ %t ")
  (tags   . "○ ")
  (todo   . "○ ")))
#+end_src

* Calfw
#+begin_src emacs-lisp 
  (use-package calfw)
  (use-package google-maps)

  (use-package calfw-org
    :config
    (setq cfw:org-agenda-schedule-args '(:timestamp)))

  (defun my/cfw:trim-text (text)
    "Trim TEXT to fit in WIDTH, without adding ellipsis that breaks formatting."
    text)
  ;; Override the default truncation function
  (advice-add 'cfw:trim :override #'my/cfw:trim-text)
#+end_src

* Org Face Customizations
#+begin_src emacs-lisp
  ;; Face customizations for org mode
  (custom-set-faces
   '(org-document-info-keyword ((t (:height 1.0))))
   '(org-document-title ((t (:height 140))))
   '(org-level-1 ((t (:height 140))))
   '(org-level-2 ((t (:height 140))))
   '(org-level-3 ((t (:height 140))))
   '(org-level-4 ((t (:height 140))))
   '(org-level-5 ((t (:height 140))))
   '(org-level-6 ((t (:height 140))))
   '(org-level-7 ((t (:height 140))))
   '(org-level-8 ((t (:height 140))))
   '(org-modern-label ((t (:height 140))))
   '(org-modern-statistics ((t (:height 140))))
   '(org-modern-tag ((t (:height 140))))
   '(org-drawer ((t (:height 140))))
   '(org-drawer-content ((t (:height 140))))
   '(variable-pitch-text ((t (:height 140))))
   '(variable-pitch ((t (:height 140))))
   '(org-property-value ((t (:height 140))))
   '(org-special-keyword ((t (:height 140)))))
#+end_src

* GitHub Integration
#+begin_src emacs-lisp
  (require 'ghub)

  (defvar my/github-pr-file "~/notes/code-reviews.org"
    "File to store GitHub PR todos.")

  (defvar my/github-pr-queries
    '(("Involved PRs" . "is:open is:pr involves:addisonbeck -author:addisonbeck")))

  (defun my/pr-exists-p (url)
    "Check if PR with URL already exists in the org file."
    (message "Checking for existing PR: %s" url)
    (when (file-exists-p my/github-pr-file)
      (message "File exists, checking content")
      (with-temp-buffer
	(insert-file-contents my/github-pr-file)
	(message "File contents loaded")
	;; Instead of using buffer positions, just check if the string exists
	(string-match-p (regexp-quote url) (buffer-string)))))

  (defun my/fetch-github-prs ()
    "Fetch PRs and create new org entries if they don't exist."
    (interactive)
    (message "Starting PR fetch")
    (let ((buf (find-file-noselect my/github-pr-file)))
      (message "Buffer created: %S" buf)
      (with-current-buffer buf
	(message "In buffer")
	(org-mode)
	(message "Org mode enabled")
	(let ((max-point (point-max)))
	  (message "Max point: %S" max-point)
	  (goto-char max-point)
	  (message "Moved to end of buffer")
	  (dolist (query-pair my/github-pr-queries)
	    (let* ((section-name (car query-pair))
		   (query (cdr query-pair)))
	      (message "Processing query: %s" section-name)
	      (let ((response (ghub-graphql
			       "query($query: String!) {
						      search(query: $query, type: ISSUE, first: 100) {
							nodes {
							  ... on PullRequest {
							    title
							    url
							    repository {
							      nameWithOwner
							    }
							    author {
							      login
							    }
							    updatedAt
							    state
							  }
							}
						      }
						    }"
			       `((query . ,query)))))
		(message "Got GraphQL response")
		(when-let ((prs (alist-get 'nodes (alist-get 'search (alist-get 'data response)))))
		  (message "Found %d PRs" (length prs))
		  (dolist (pr prs)
		    (message "Processing PR: %S" pr)
		    (let-alist pr
		      (message "Checking if PR exists: %s" .url)
		      (let ((exists-result (my/pr-exists-p .url)))
			(message "PR exists check returned: %S" exists-result)
			(unless exists-result
			  (message "PR doesn't exist, inserting")
			  (let ((insert-point (point)))
			    (message "Current point before insert: %S" insert-point)
			    (insert (format "* TODO %s\nSCHEDULED: <%s>\n:PROPERTIES:\n:PR_URL: %s\n:REPO: %s\n:AUTHOR: %s\n:END:\n"
					    .title
					    (format-time-string "%Y-%m-%d")
					    .url
					    .repository.nameWithOwner
					    .author.login))
			    (message "Insert completed"))))))))))))
      (message "Saving buffer")
      (save-buffer)
      (message "PR fetch completed")))

  (global-set-key (kbd "C-c g p") #'my/fetch-github-prs)

  (defun remove-duplicate-org-entries ()
    (interactive)
    (let ((seen-urls (make-hash-table :test 'equal)))
      (org-map-entries
       (lambda ()
	 (let ((pr-url (org-entry-get nil "PR_URL")))
	   (if (and pr-url (gethash pr-url seen-urls))
	       (org-cut-subtree)
	     (when pr-url
	       (puthash pr-url t seen-urls))))))))
#+end_src

* Which Key Configuration
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode)
    (setq which-key-idle-delay 0.3
	  which-key-prefix-prefix "→"
	  which-key-sort-order 'which-key-key-order-alpha
	  which-key-side-window-location 'bottom
	  which-key-side-window-max-height 0.25))
#+end_src

* Theme Configuration
#+begin_src emacs-lisp
  (use-package gruvbox-theme
    :ensure t
    :config
    (load-theme 'gruvbox-light-hard t))

  (defun my/toggle-theme ()
    "Toggle between gruvbox light and dark themes."
    (interactive)
    (if (eq (car custom-enabled-themes) 'gruvbox-light-hard)
	(progn
	  (disable-theme 'gruvbox-light-hard)
	  (load-theme 'gruvbox-dark-hard t)
	  (message "Switched to dark theme"))
      (progn
	(disable-theme 'gruvbox-dark-hard)
	(load-theme 'gruvbox-light-hard t)
	(message "Switched to light theme"))))


  (custom-set-faces
   `(org-warning ((t (:foreground ,(if (eq 'dark (frame-parameter nil 'background-mode))
				       "#83a598"  ; gruvbox-dark blue
				     "#076678")  ; gruvbox-light blue
				  ))))
   '(org-agenda-deadline-face ((t (:inherit org-warning :foreground nil :background nil :weight bold))))
   '(org-upcoming-deadline ((t (:inherit org-warning :foreground nil :background nil :weight bold))))
   '(org-scheduled-previously ((t (:inherit org-warning :foreground nil :background nil :weight normal))))
   )
#+end_src

* Spell Checking
#+begin_src emacs-lisp :tangle no
  (use-package flyspell
    :ensure nil 
    :config
    (setq ispell-program-name "aspell")
    (add-hook 'text-mode-hook #'flyspell-mode)
    (add-hook 'prog-mode-hook #'flyspell-prog-mode))

  (use-package flyspell-correct
    :ensure nil 
    :config
    (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-wrapper))
#+end_src
* Elfeed Configuration
#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    ("C-x w" . elfeed)
    :config
    (evil-define-key 'normal elfeed-search-mode-map
		     (kbd "r") 'elfeed-search-untag-all-unread
		     (kbd "u") 'elfeed-search-tag-all-unread
		     (kbd "RET") 'elfeed-search-show-entry
		     (kbd "q") 'quit-window
		     (kbd "g") 'elfeed-update
		     (kbd "G") 'elfeed-search-update--force)

    (evil-define-key 'normal elfeed-show-mode-map
		     (kbd "r") 'elfeed-show-untag-unread
		     (kbd "u") 'elfeed-show-tag-unread
		     (kbd "q") 'quit-window
		     (kbd "n") 'elfeed-show-next
		     (kbd "p") 'elfeed-show-prev
		     (kbd "b") 'elfeed-show-visit)

    (setq elfeed-search-filter "+unread")
    (setq elfeed-sort-order 'descending))

  (use-package elfeed-protocol
    :ensure t
    :after elfeed
    :custom
    (elfeed-use-curl t)
    (elfeed-protocol-enabled-protocols '(fever))
    (setq elfeed-protocol-log-trace t)
    (elfeed-protocol-fever-update-unread-only t)
    (elfeed-protocol-fever-fetch-category-as-tag t)
    (elfeed-protocol-feeds '(("fever+https://me@rss.addisonbeck.dev"
			      :api-url "https://rss.addisonbeck.dev/api/fever.php"
			      :use-authinfo t)))
    (elfeed-protocol-enabled-protocols '(fever))
    :config
    (elfeed-protocol-enable))

  (defun my/elfeed-reset ()
    "Reset elfeed database and update."
    (interactive)
    (when (yes-or-no-p "Really reset elfeed database? ")
      (let ((db (expand-file-name "~/.elfeed/index"))
	    (data (expand-file-name "~/.elfeed/data")))
	(message "Checking paths: index=%s data=%s" db data)

	;; Try to close elfeed first
	(elfeed-db-unload)
	(message "Database unloaded")

	;; Delete files with error checking
	(condition-case err
	    (progn
	      (when (file-exists-p db)
		(delete-file db)
		(message "Deleted index file"))
	      (when (file-exists-p data)
		(delete-directory data t)
		(message "Deleted data directory")))
	  (error (message "Error during deletion: %s" err)))

	;; Restart elfeed
	(elfeed)
	(elfeed-search-update--force)
	(message "Reset complete"))))

  ;; Set elfeed-show-entry-switch to display in a side window
  (setq elfeed-show-entry-switch #'elfeed-display-buffer-right)

  ;; Define the display function for right split
  (defun elfeed-display-buffer-right (buf)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer 
       buf
       '((display-buffer-reuse-window display-buffer-in-side-window)
	 (side . right)
	 (window-width . 0.5)))))

  ;; Optional: Make elfeed respect this two-pane setup when updating
  (defadvice elfeed-search-update (after configure-windows activate)
    (when (get-buffer "*elfeed-entry*")
      (elfeed-display-buffer-right (get-buffer "*elfeed-entry*"))))

  ;; Optional: Return focus to search buffer after showing entry
  (defadvice elfeed-show-entry (after switch-to-search activate)
    (select-window (get-buffer-window "*elfeed-search*")))

  ;;(require 'elfeed-tube)
  ;;(elfeed-tube-setup)
  ;;(define-key elfeed-show-mode-map (kbd "F") 'elfeed-tube-fetch)
  ;;(define-key elfeed-show-mode-map [remap save-buffer] 'elfeed-tube-save)
  ;;(define-key elfeed-search-mode-map (kbd "F") 'elfeed-tube-fetch)
  ;;(define-key elfeed-search-mode-map [remap save-buffer] 'elfeed-tube-save)
  ;;(require 'elfeed-tube-mpv)
  ;;(define-key elfeed-show-mode-map (kbd "C-c C-f") 'elfeed-tube-mpv-follow-mode)
  ;;(define-key elfeed-show-mode-map (kbd "C-c C-w") 'elfeed-tube-mpv-where)
#+end_src

* GPTel Configuration
#+begin_src emacs-lisp
  (use-package gptel
    :config
    ;; Enable debug logging
    ;; Token access for GitHub Copilot
    (defvar gptel-github-api-key
      (lambda ()
	(when-let ((auth (car (auth-source-search
			       :host "github.copilot"
			       :require '(:secret)))))
	  (let ((token (plist-get auth :secret)))
	    (if (functionp token)
		(funcall token)
	      token)))))

    (defun gptel-copilot--exchange-token ()
      (let* ((github-token (if (functionp gptel-github-api-key)
			       (funcall gptel-github-api-key)
			     gptel-github-api-key))
	     (url-request-method "GET")
	     (url-request-extra-headers
	      `(("Authorization" . ,(format "Bearer %s" github-token))
		("Accept" . "application/json")))
	     response-buffer token-str)
	(setq response-buffer
	      (url-retrieve-synchronously
	       "https://api.github.com/copilot_internal/v2/token"
	       t nil 30))
	(when response-buffer
	  (with-current-buffer response-buffer
	    (goto-char (point-min))
	    (when (re-search-forward "^$" nil t)
	      (forward-char)
	      (condition-case nil
		  (let ((json-response (json-read)))
		    (setq token-str (cdr (assoc 'token json-response))))
		(error nil)))
	    (kill-buffer response-buffer)))
	token-str))

    ;; Store the exchanged token
    (defvar gptel-copilot--exchanged-token nil)
    (setq gptel-copilot--exchanged-token (gptel-copilot--exchange-token))

    ;; Update gptel-api-key to use the exchanged token
    (setq gptel-api-key
	  (lambda ()
	    (or gptel-copilot--exchanged-token
		(setq gptel-copilot--exchanged-token
		      (gptel-copilot--exchange-token)))))

    ;; Advice to include full path in message
    (defun gptel--insert-at-beginning-with-path (initial-point)
      "Include full path when showing buffer contents."
      (let ((full-path (buffer-file-name)))
	(goto-char initial-point)
	(insert
	 (format "In file %s:\n\n"
		 (if full-path
		     (expand-file-name full-path)
		   (buffer-name))))))

    (advice-add 'gptel--insert-at-beginning :override #'gptel--insert-at-beginning-with-path)

    ;; Create custom backend for GitHub Copilot
    (setq gptel-copilot-backend
	  (gptel-make-openai
	   "github-copilot"
	   :host "api.githubcopilot.com/"
	   :endpoint "chat/completions"
	   :key 'gptel-api-key
	   :stream t
	   :models '((gpt-4o-2024-08-06 :name "gpt-4o-2024-08-06")
		     (claude-3.5-sonnet :name "claude-3.5-sonnet")
		     (claude-3.7-sonnet :name "claude-3.7-sonnet")
		     (claude-3.7-sonnet-thought :name "claude-3.7-sonnet-thought")
		     (o1-2024-12-17 :name "o1-2024-12-17")
		     (o1-mini-2024-09-12 :name "o1-mini-2024-09-12"))
	   :header (lambda ()
		     `(("Authorization" . ,(format "Bearer %s" (funcall gptel-api-key)))
		       ("Content-Type" . "application/json")
		       ("Accept" . "application/json")
		       ("Copilot-Integration-Id" . "vscode-chat")
		       ("editor-version" . "vscode/1.84.2")
		       ("editor-plugin-version" . "1.138.0")
		       ("user-agent" . "GithubCopilot/1.138.0")))))

    (advice-add 'gptel--url-parse-response :around
		(lambda (orig-fun backend proc-info)
		  (let ((result (funcall orig-fun backend proc-info)))
		    (when (and (stringp (cadr result))
			       (string-match-p "HTTP/2 401" (cadr result)))
		      (message "Token expired, refreshing and retrying...")
		      (setq gptel-copilot--exchanged-token nil)
		      ;; Get new token
		      (funcall gptel-api-key)
		      ;; Retry the request
		      (let ((request-data (plist-get proc-info :request-data)))
			(when request-data
			  (gptel-request request-data))))
		    result)))

    (defun test-gptel-token-refresh ()
      "Test gptel token refresh logic."
      (interactive)
      (message "=== Starting Token Test ===")
      (message "Current token (first 50 chars): %s..."
	       (substring gptel-copilot--exchanged-token 0 50))
      ;; Force token refresh by setting to nil
      (setq gptel-copilot--exchanged-token nil)
      ;;(message "Cleared token, making request...")
      ;; Make request that should trigger token refresh
      ;;(gptel-request
      ;;"Test message"
      ;;:callback (lambda (response info)
      ;;(message "=== Request completed ===")
      ;;(message "New token (first 50 chars): %s..."
      ;;(substring gptel-copilot--exchanged-token 0 50))
      ;;(message "Response status: %s" (plist-get info :status))
      ;;(message "Got response: %s" response)))
      )

    (defun get-anthropic-api-key ()
      (when-let ((auth (car (auth-source-search
			     :host "api.anthropic.com"
			     :require '(:secret)))))
	(let ((token (plist-get auth :secret)))
	  (if (functionp token)
	      (funcall token)
	    token))))

    (defun get-gemini-api-key ()
      (when-let ((auth (car (auth-source-search
			     :host "api.gemini.com"
			     :require '(:secret)))))
	(let ((token (plist-get auth :secret)))
	  (if (functionp token)
	      (funcall token)
	    token))))

    (gptel-make-anthropic "Claude"          
			  :stream t
			  :key #'get-anthropic-api-key)

    (gptel-make-gemini "Gemini"          
		       :key #'get-gemini-api-key)

    ;;(gptel-make-anthropic "claude" 
    ;;:key #'get-anthropic-api-key
    ;;:stream t
    ;;:models '(claude-3-7-sonnet-20250219)
    ;;:header (lambda () (when-let* ((key (gptel--get-api-key)))
    ;;`(("x-api-key" . ,key)
    ;;("anthropic-version" . "2023-06-01")
    ;;("anthropic-beta" . "pdfs-2024-09-25")
    ;;("anthropic-beta" . "output-128k-2025-02-19")
    ;;("anthropic-beta" . "prompt-caching-2024-07-31"))))
    ;;:request-params '(:max_tokens 4096))

    ;;(gptel-make-anthropic "claude-thinking" 
    ;;:key #'get-anthropic-api-key
    ;;:stream t
    ;;:models '(claude-3-7-sonnet-20250219)
    ;;:header (lambda () (when-let* ((key (gptel--get-api-key)))
    ;;`(("x-api-key" . ,key)
    ;;("anthropic-version" . "2023-06-01")
    ;;("anthropic-beta" . "pdfs-2024-09-25")
    ;;("anthropic-beta" . "output-128k-2025-02-19")
    ;;("anthropic-beta" . "prompt-caching-2024-07-31"))))
    ;;:request-params '(:thinking (:type "enabled" :budget_tokens 2048)
    ;;:max_tokens 4096))

    (setq gptel-log-level 'debug)
    ;; Use org-mode for gptel buffers
    (setq gptel-default-mode 'org-mode)
    ;; Enable branching conversations in org-mode
    (setq gptel-org-branching-context t)
    (setq gptel-confirm-tool-calls t)
    (setq gptel-include-tool-results t)

    ;; Update prompt/response prefixes for org-mode to be compatible with branching conversations
    (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "@user\n")
    (setf (alist-get 'org-mode gptel-response-prefix-alist) "@assistant\n")

    (setq gptel-backend gptel-copilot-backend)
    (setq gptel-model 'claude-3.7-sonnet)
    (setq gptel-default-mode 'org-mode))
#+end_src

* GPTel Context Management

These are helper functions and automations for being efficient with tokens in GPTel.

This doesn't work

#+begin_src emacs-lisp
  ;; Context minification function for GPTel
  (defun my/gptel-minify-context ()
    "Minify the current gptel chat buffer context to reduce tokens."
    (interactive)
    (when (derived-mode-p 'gptel-mode)
      (let ((inhibit-read-only t)
	    (modified (buffer-modified-p)))
	(save-excursion
	  ;; Remove excess blank lines
	  (goto-char (point-min))
	  (while (re-search-forward "\n\n\n+" nil t)
	    (replace-match "\n\n"))

	  ;; Collapse code blocks to show minimal context
	  (goto-char (point-min))
	  (while (re-search-forward "```\\([^`\n]*\\)\n\\([^`]*?\\)\n```" nil t)
	    (let* ((lang (match-string 1))
		   (code (match-string 2))
		   (lines (split-string code "\n"))
		   (total-lines (length lines))
		   (preview-lines 3)
		   (minified-code
		    (if (> total-lines (* 2 preview-lines))
			(concat
			 (string-join (seq-take lines preview-lines) "\n")
			 "\n... "
			 (number-to-string (- total-lines (* 2 preview-lines)))
			 " lines collapsed ...\n"
			 (string-join (seq-take-last preview-lines lines) "\n"))
		      code)))
	      (replace-match (format "```%s\n%s\n```" lang minified-code))))

	  ;; Optionally truncate very long responses
	  (goto-char (point-min))
	  (while (re-search-forward "^Assistant: \\([^\n]*\\(?:\n[^\n]+\\)*\\)" nil t)
	    (let* ((response (match-string 1))
		   (lines (split-string response "\n"))
		   (max-lines 20))
	      (when (> (length lines) max-lines)
		(let ((truncated-response
		       (concat
			(string-join (seq-take lines (/ max-lines 2)) "\n")
			"\n... "
			(number-to-string (- (length lines) max-lines))
			" lines summarized ...\n"
			(string-join (seq-take-last (/ max-lines 2) lines) "\n"))))
		  (replace-match (concat "Assistant: " truncated-response))))))

	  ;; Remove trailing whitespace
	  (delete-trailing-whitespace))

	;; Restore modification state
	(set-buffer-modified-p modified))

      ;; Provide feedback on reduction
      (message "Context minified. Use M-x revert-buffer to restore if needed.")))

  ;; Bind minification function in gptel-mode
  (define-key gptel-mode-map (kbd "C-c C-m") #'my/gptel-minify-context)
#+end_src

* GPTel Tools

This section defines agenic tools capabilities for gptel. It's my answer to the "stdlib for LLMs" idea.

Some notes:

1. All tools _must_ have an arguement. This can be just a dummy arguement like `read_gptel_tools_section`.

** General Tools Setup
This block contains helper functions and variables used by multiple tools. These are not tools themselves but support the tool infrastructure.

#+begin_src emacs-lisp
  (setq gptel-use-tools t
	gptel-tools nil)  

  (defun register-gptel-tool (tool-name)
    "Register a tool with gptel by its NAME."
    (add-to-list 'gptel-tools (gptel-get-tool tool-name)))

  ;; Make sure repomix is available
  ;;(unless (executable-find "repomix")
  ;;(message "Warning: repomix not found in PATH. The repomix tool won't work until installed."))


  (defvar my/file-bookmarks
    '(("emacs config" . (:path "~/nix/system/with/user/with/program/emacs.org"
			       :description "My literate org based emacs configuration"))
      ("inbox" . (:path "~/notes/inbox.org"
			:description "My inbox for my TODOs and notes"))
      ))
#+end_src

** Repomix Integration

#+begin_src emacs-lisp :tangle no
  (defun my/run-repomix (directory)
    "Run repomix on DIRECTORY to generate context for LLM."
    (message "Running repomix on directory: %s" directory)
    (let* ((default-directory directory)
	   (output-buffer (generate-new-buffer " *repomix-output*"))
	   (command "repomix . -i 'node_modules,dist,.git,*.min.js,*.bundle.js'"))
      (with-current-buffer output-buffer
	(let ((exit-code (call-process-shell-command command nil t)))
	  (if (= exit-code 0)
	      (let ((output (buffer-string)))
		(kill-buffer output-buffer)
		output)
	    (let ((error-msg (format "Repomix failed with exit code %d: %s"
				     exit-code (buffer-string))))
	      (kill-buffer output-buffer)
	      (error error-msg)))))))

  (gptel-make-tool
   :name "repomix"
   :function #'my/run-repomix
   :description "Run repomix on a directory to analyze and summarize code for context.
  This generates a well-structured overview of the codebase including directory structure,
  key files, important functions, and insights about the project architecture."
   :args '((:name "directory"
		  :type string
		  :description "Directory path to analyze with repomix"))
   :category "code-analysis")

  (register-gptel-tool "repomix")
#+end_src

** Read File

This tool hooks in to my file reading function and bookmarks list to enable LLMs to edit specific files at will and all files behind a warning.

#+begin_src emacs-lisp :tangle no
  (defun my/read-file (file-id)
    "Read complete contents of a file.
		  FILE-ID can be a bookmark name or full path."
    (let* ((bookmark (alist-get file-id my/file-bookmarks nil nil #'equal))
	   (file-path (expand-file-name
		       (if bookmark 
			   (plist-get bookmark :path)
			 file-id))))
      (with-temp-buffer
	(insert-file-contents file-path)
	(buffer-substring-no-properties (point-min) (point-max)))))

  (gptel-make-tool
   :name "read_file"
   :function #'my/read-file
   :description "Read a file's complete contents"
   :args '((:name "file-id"
		  :type string
		  :description "can be a full path or one of the following bookmarks:
		      - 'emacs config' for my emacs configuration
		      - 'inbox' for my org mode inbox file")
	   ))
  (register-gptel-tool "read_file")
#+end_src

** Write File

This tool hooks in to my file  writing function and bookmarks list to enable LLMs to edit specific files at will and all files behind a warning.

#+begin_src emacs-lisp :tangle no
  (defun my/parse-search-replace-blocks (content)
    "Extract list of changes from content with search/replace blocks."
    (with-temp-buffer
      (insert content)
      (let (changes)
	(goto-char (point-min))
	(while (re-search-forward "<<<<<<< SEARCH\n\\([^=]*?\\)\n=======\n\\([^>]*?\\)\n>>>>>>> REPLACE" nil t)
	  (push (list :search (match-string 1)
		      :replace (match-string 2))
		changes))
	(nreverse changes))))

  (defun my/apply-changes (original-content changes)
    "Apply changes specified in search/replace block format to ORIGINAL-CONTENT."
    (with-temp-buffer
      (insert original-content)
      (dolist (change changes)
	(let ((search (plist-get change :search))
	      (replace (plist-get change :replace)))
	  (goto-char (point-min))
	  (while (search-forward search nil t)
	    (replace-match replace t t))))
      (buffer-string)))

  (defun my/write-file (file-id content)
    "Write file with changes in search/replace block format.
	    FILE-ID can be a bookmark name or full path.
	    CONTENT must contain search/replace blocks showing what to change."
    (let* ((bookmark (alist-get file-id my/file-bookmarks nil nil #'equal))
	   (file-path (expand-file-name
		       (if bookmark 
			   (plist-get bookmark :path)
			 file-id)))
	   (original (my/read-file file-id))
	   (changes (my/parse-search-replace-blocks content))
	   (new-content (my/apply-changes original changes)))
      ;; Check if content is unchanged
      (when (string= original new-content)
	(error "No changes detected - the diff would be empty"))
      ;; Validate content preservation
      (when (< (length new-content) (* 0.95 (length original)))
	(error "Error: New content is significantly smaller than original"))
      ;; Show git-style diff and confirm
      (let* ((temp-orig (make-temp-file "gptel-orig-"))
	     (temp-new (make-temp-file "gptel-new-"))
	     (diff-buffer (get-buffer-create "*File Changes Preview*"))
	     (confirm-changes nil))
	;; Write both versions to temp files
	(write-region original nil temp-orig)
	(write-region new-content nil temp-new)
	;; Generate and display diff
	(with-current-buffer diff-buffer
	  (erase-buffer)
	  (insert "Proposed changes to " file-path ":\n\n")
	  (call-process "git" nil t nil "diff" "--no-index" "--color=never" temp-orig temp-new)
	  ;; Enable diff-mode for syntax highlighting
	  (diff-mode)
	  (goto-char (point-min))
	  (display-buffer diff-buffer)
	  (setq confirm-changes (yes-or-no-p "Apply these changes? ")))
	;; Cleanup
	(delete-file temp-orig)
	(delete-file temp-new)
	(kill-buffer diff-buffer)
	(if confirm-changes
	    (progn
	      (write-region new-content nil file-path)
	      (format "Updated %s" file-path))
	  (format "Changes cancelled by user. Seek feedback before trying again!")))))

  (gptel-make-tool
   :name "write_file"
   :function #'my/write-file
   :description "Modify specific sections of a file while preserving all other content. If a failure occurs do not try again without asking me first. Offer to commit with git_commit after modifying files."
   :args '((:name "file-id"
		  :type string
		  :description "can be a full path or one of the following bookmarks:
	      - 'emacs config' for my emacs configuration
	      - 'inbox' for my org mode inbox file")
	   (:name "content"
		  :type string
		  :description "search/replace blocks showing what to change

  The CONTENT argument _must_ adhere *strictly* to this format, starting *exactly* with '<<<<<<< SEARCH' and containing only search/replace blocks:

  <<<<<<< SEARCH
  {text to find and replace}
  =======
  {new text to insert}
  >>>>>>> REPLACE

  - Do NOT include lines meant to call write_file in the CONTENT arguement!
  - You can include multiple search/replace blocks to make multiple changes.
  - The search text must match exactly what is in the file.
  ")))

  (register-gptel-tool "write_file")
#+end_src

** Fetch_Webpage

#+begin_src emacs-lisp 
  (gptel-make-tool
   :name "fetch_webpage"
   :function (lambda (url)
	       (message "Fetching URL: %s" url)
	       (let ((buffer (url-retrieve-synchronously url t nil 30)))
		 (when buffer
		   (with-current-buffer buffer
		     (goto-char (point-min))
		     (re-search-forward "^$" nil t) ; Skip headers
		     (forward-char)
		     ;; Basic HTML cleanup: Convert to plain text
		     (require 'shr)
		     (let* ((dom (libxml-parse-html-region (point) (point-max)))
			    (text-buffer (generate-new-buffer " *temp*")))
		       (with-current-buffer text-buffer
			 (shr-insert-document dom)
			 ;; Clean up the text and ensure it's JSON-safe
			 (let ((content (replace-regexp-in-string 
					 "[\u0000-\u001F\u007F]+" " "
					 (buffer-substring-no-properties (point-min) (point-max)))))
			   (kill-buffer text-buffer)
			   (kill-buffer buffer)
			   ;; Ensure we return a proper JSON string
			   content)))))))
   :description "fetch the contents of a webpage given its url"
   :args '((:name "url"
		  :type string
		  :description "url of the webpage to fetch"))
   :category "web")

  (register-gptel-tool "fetch_webpage")
#+end_src

** Git_Commit

#+begin_src emacs-lisp :tangle no
  (defun my/git-commit-changes (project message)
    "Commit all changes in the specified project repository with the given message."
    (let* ((project-root (if (file-name-absolute-p project)
			     project
			   (let ((found (seq-find (lambda (p)
						    (string-match-p project (file-name-nondirectory p)))
						  projectile-known-projects)))
			     (or found (error "Project not found: %s" project)))))
	   (default-directory project-root)
	   (status (shell-command-to-string "git status --porcelain")))
      (if (string-empty-p status)
	  "No changes to commit"
	(shell-command-to-string (format "git add -A && git commit -m %s"
					 (shell-quote-argument message))))))

  (gptel-make-tool
   :name "git_commit"
   :function #'my/git-commit-changes
   :description "Commits all changes in the specified Git repository."
   :args '((:name "project"
		  :type string
		  :description "project name or full path to git repository")
	   (:name "message"
		  :type string
		  :description "commit message"))
   :category "git")

  (register-gptel-tool "git_commit")
#+end_src

** Create_File

#+begin_src emacs-lisp :tangle no
  (gptel-make-tool
   :name "create_file"
   :function (lambda (path content)
	       (let ((dir (file-name-directory path)))
		 (condition-case err
		     (cond
		      ((file-exists-p path)
		       (error "File already exists: %s" path))
		      (t
		       (when dir
			 (make-directory dir t))
		       (write-region content nil path)
		       (format "Successfully created file: %s" path)))
		   (error
		    (format "Error creating file: %s" (error-message-string err))))))
   :description "Creates a new file with specified content, creating any necessary parent directories. Will not overwrite existing files."
   :args '((:name "path"
		  :type string
		  :description "path to the file to create")
	   (:name "content"
		  :type string
		  :description "content to write to the file"))
   :category "file")
#+end_src

** Project Context Tool

#+begin_src emacs-lisp :tangle no
  (defun my/project-context-for-llm (project-root &optional scope)
    "Generate project context for LLM consumption.
		PROJECT-ROOT is the directory to analyze.
		SCOPE can be 'structure (directory only), 'core (key files), or 'full (both)."
    (let* ((project-root (expand-file-name project-root))
	   (default-directory project-root)
	   (context-parts '()))

      ;; Add project structure with depth limitation
      (push (concat "Project Structure:\n" 
		    (shell-command-to-string "tree -L 3 --gitignore --noreport"))
	    context-parts)

      ;; Add key files only for core or full scopes
      (when (or (eq scope 'core) (eq scope 'full))
	(let* ((key-files '("README.md" "package.json" "Cargo.toml" "pyproject.toml"
			    "flake.nix" "default.nix" "home.nix"
			    "Makefile" "justfile"))
	       (found-files '()))

	  ;; Find important files that actually exist
	  (dolist (file key-files)
	    (when (file-exists-p file)
	      (push file found-files)))

	  ;; Add file summary header
	  (push "\nKey Files Found:" context-parts)
	  (push (mapconcat #'identity found-files "\n") context-parts)

	  ;; Add content of files with size checks and truncation
	  (push "\nFile Contents:" context-parts)
	  (dolist (file found-files)
	    (let ((file-size (nth 7 (file-attributes file))))
	      (cond
	       ;; Skip large files completely
	       ((> file-size 15000)
		(push (format "\n=== %s === (TOO LARGE: %dKB - skipped)" 
			      file (/ file-size 1024)) 
		      context-parts))

	       ;; Truncate medium files
	       ((> file-size 5000)
		(push (format "\n=== %s === (TRUNCATED: %dKB)" 
			      file (/ file-size 1024)) 
		      context-parts)
		(push (with-temp-buffer
			(insert-file-contents file nil 0 2000)
			(concat (buffer-string) 
				"\n[...file truncated...]\n"))
		      context-parts))

	       ;; Include small files completely
	       (t
		(push (format "\n=== %s ===" file) context-parts)
		(push (with-temp-buffer
			(insert-file-contents file)
			(buffer-string))
		      context-parts)))))))

      ;; Join all parts in reverse order (since we used push)
      (mapconcat #'identity (reverse context-parts) "\n")))

  (gptel-make-tool
   :name "project_context"
   :function #'my/project-context-for-llm
   :description "Get structural and content context for a project directory"
   :args '((:name "project"
		  :type string
		  :description "project name or path")
	   (:name "scope"
		  :type string
		  :description "context scope: 'structure, 'core, or 'full"))
   :category "project")

  (register-gptel-tool "project_context")
#+end_src

* MCP Configuration
#+begin_src emacs-lisp
  (require 'mcp-hub)
  (setq mcp-server-start-time 120) 

  (defun my/get-github-mcp-token ()
    (when-let ((auth (car (auth-source-search :host "api.github.com" :require '(:secret)))))
      (let ((token (plist-get auth :secret)))
	(if (functionp token) (funcall token) token))))

  ;; Configure the GitHub MCP server (using Docker)
  (setq mcp-hub-servers
	`(
	  ("nix-folder" . (:command "npx" :args ("-y" "@modelcontextprotocol/server-filesystem" "~/nix")))
	  ("fetch" . (:command "uvx" :args ("mcp-server-fetch")))
	  ("github-mcp" . (:command "docker"
				    :args ("run" "-i" "--rm"
					   "-e" "GITHUB_PERSONAL_ACCESS_TOKEN"
					   "ghcr.io/github/github-mcp-server")
				    :env (:GITHUB_PERSONAL_ACCESS_TOKEN ,(my/get-github-mcp-token))))
	  ))


  (add-hook 'after-init-hook #'mcp-hub-start-all-server)

  (defun gptel-mcp-register-tool ()
    (interactive)
    (let ((tools (mcp-hub-get-all-tool :asyncp t :categoryp t)))
      (mapcar #'(lambda (tool)
		  (apply #'gptel-make-tool
			 tool))
	      tools)))

  (defun gptel-mcp-use-tool ()
    "Activate all MCP tools for gptel."
    (interactive)
    (let ((tools (mcp-hub-get-all-tool :asyncp t :categoryp t)))
      (mapcar #'(lambda (tool)
		  (let ((path (list (plist-get tool :category)
				    (plist-get tool :name))))
		    (add-to-list 'gptel-tools (gptel-get-tool path))))
	      tools)))

  (defun gptel-mcp-close-use-tool ()
    "Deactivate all MCP tools for gptel."
    (interactive)
    (let ((tools (mcp-hub-get-all-tool :asyncp t :categoryp t)))
      (mapcar #'(lambda (tool)
		  (let ((path (list (plist-get tool :category)
				    (plist-get tool :name))))
		    (setq gptel-tools
			  (cl-remove-if #'(lambda (tool-item)
					    (equal path
						   (list (gptel-tool-category tool-item)
							 (gptel-tool-name tool-item))))
					gptel-tools))))
	      tools)))
#+end_src

* Path Copying Functions

#+begin_src emacs-lisp
  (defun copy-file-path ()
    "Copy the current buffer file path to the kill ring."
    (interactive)
    (let ((filepath (buffer-file-name)))
      (when filepath
	(kill-new filepath)
	(message "Copied: %s" filepath))))

  (defun copy-file-name ()
    "Copy the current buffer file name to the kill ring."
    (interactive)
    (let ((filename (file-name-nondirectory (buffer-file-name))))
      (when filename
	(kill-new filename)
	(message "Copied: %s" filename))))

  (defun copy-directory-path ()
    "Copy the current buffer directory path to the kill ring."
    (interactive)
    (let ((dirpath (file-name-directory (buffer-file-name))))
      (when dirpath
	(kill-new dirpath)
	(message "Copied: %s" dirpath))))
#+end_src

* Avy
#+begin_src emacs-lisp
  (require 'avy)
  (define-key evil-normal-state-map (kbd "s") 'avy-goto-char-timer)
#+end_src

* rg
#+begin_src emacs-lisp
  (require 'rg)
#+end_src

* Custom magit functions
** Reset current buffer
#+begin_src emacs-lisp
  (defun reset-file-to-revision ()
    "Reset the current buffer's file to a specified revision using Magit."
    (interactive)
    (require 'magit)
    (let* ((file-path (buffer-file-name))
	   (default-directory (magit-toplevel))
	   (revision (magit-read-branch-or-commit "Reset file to revision")))
      (when (and file-path revision)
	(let ((relative-file-path (file-relative-name file-path default-directory)))
	  (magit-run-git "checkout" revision "--" relative-file-path)
	  (revert-buffer t t t)
	  (message "File reset to %s" revision)))))
#+end_src
* Custom Commands For Projects

I use this space to write a bunch of custom commands for interacting with projects I work on frequently.

** Enable complex color support in compile buffers

#+begin_src emacs-lisp
  (use-package ansi-color
    :config
    (defun my/colorize-compilation ()
      "Colorize from `compilation-filter-start' to `point'."
      (let ((inhibit-read-only t))
	(ansi-color-apply-on-region
	 compilation-filter-start (point))))

    (add-hook 'compilation-filter-hook #'my/colorize-compilation)

    (setq ansi-color-for-comint-mode t)
    (setq comint-terminfo-terminal "xterm-256color"))
#+end_src

#+RESULTS:
: t

** Builds for the Bitwarden Nx PoC project

#+begin_src emacs-lisp
  (defun bitwarden/nx-poc-npm-i ()
    "Run npm ci in the nx PoC"
    (interactive)
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-functionl 
	    (lambda (_mode) (format "*nx-poc-npm-i*"))))
      (compile "npm i" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-web ()
    "Build the web vault of the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/web"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-web-build*"))))
      (compile "npm run build:watch" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-browser-chrome ()
    "Build the chrome extension of the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/browser"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-chrome-build*"))))
      (compile "npm run build:watch:chrome" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-browser-firefox ()
    "Build the chrome extension of the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/browser"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-firefox-build*"))))
      (compile "npm run build:watch:firefox" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/run-nx-poc-desktop ()
    "Build the desktop applicaton in the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/desktop"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-desktop-build*"))))
      (compile "npm run build:watch" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/build-nx-poc-cli ()
    "Build the cli in the nx poc project with a uniquely named buffer."
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nx-poc") "/apps/cli"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-cli-build*"))))
      (compile "npm run build" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx-poc-nx-report ()
    "Runs nx report in the poc project"
    (interactive)
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-poc-nx-report*"))))
      (compile "npx nx report" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx/build (target)
    "Build the NX poc using NX for TARGET"
    (interactive
     (list (completing-read "Target to build: " 
			    '("common" "angular" "web" "cli" "desktop" "browser")
			    nil nil nil nil "common")))
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-pox-%s-build*" target))))
      (compile (format "npx nx build %s" target) t)))
#+end_src

#+begin_src emacs-lisp
(defun bitwarden/nx/serve (target)
  "Serve the NX poc using NX for TARGET"
  (interactive
   (list (completing-read "Target to build: " 
                         '("web" "desktop" "browser")
                         nil nil nil nil "web")))
  (let* ((default-directory (my/get-project-path "nx-poc"))
         (compilation-buffer-name-function 
          (lambda (_mode) (format "*nx-pox-%s-serve*" target))))
    (compile (format "npx nx serve %s" target) t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/nx/start (target)
    "Start the NX poc using NX for TARGET"
    (interactive
     (list (completing-read "Target to build: " 
			    '("cli")
			    nil nil nil nil "cli")))
    (let* ((default-directory (my/get-project-path "nx-poc"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nx-pox-%s-start*" target))))
      (compile (format "npx nx start %s --verbose" target) t)))
#+end_src

#+begin_src emacs-lisp
(defun bitwarden/nx/cleanup ()
  "Clean up the nx poc project"
  (interactive)
  (let* ((default-directory (my/get-project-path "nx-poc"))
         (compilation-buffer-name-function 
          (lambda (_mode) (format "*nx-poc-cleanup*"))))
    (compile "rm -rf node_modules ; rm -rf .nx" t)))
#+end_src

** My Nix Systems Configuration

#+begin_src emacs-lisp
  (defun my/nix/rebuild (system)
    "Rebuild my nix config for the specified SYSTEM."
    (interactive
     (list (completing-read "System to rebuild: " 
			    '("air" "bw")
			    nil nil nil nil "air")))
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-%s-rebuild*" system))))
      (compile (format "nix develop --command rebuild %s" system) t)))
#+end_src

#+RESULTS:
: my/nix-rebuild

#+begin_src emacs-lisp
(defun my/nix/format ()
  "Run the formatters in my nix systems configuration"
  (interactive)
  (let* ((default-directory (my/get-project-path "nix"))
         (compilation-buffer-name-function 
          (lambda (_mode) (format "*nix-systems-format*"))))
    (compile "nix develop --command apply formatting" t)))
#+end_src

#+RESULTS:
: my/nix-format

#+begin_src emacs-lisp
  (defun my/nix/commit (message)
    "Commit all files in my nix config with MESSAGE"
    (interactive
     (list (read-string "Commit message: " nil nil nil)))
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-commit*"))))
      (compile (format "git add . ; git commit -m %s ; git pull ; git push" message) t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/update-flake-lock ()
    "Update flake lock in my nix systems config"
    (interactive)
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-flake-lock-update*"))))
      (compile "nix flake update" t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/check-status ()
    "Check the git status of my nix systems config"
    (interactive)
    (let* ((default-directory (my/get-project-path "nix"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-git-status*"))))
      (compile "git status" t)))
#+end_src

#+begin_src emacs-lisp
  (defun my/nix/update-minecraft-packwize ()
    "Update the pacckages for the packwiz server for my kids"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "nix") "/packwiz/bonesfamily"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*nix-systems-packwiz-packages*"))))
      (compile "packwiz " t)))
#+end_src

#+RESULTS:
: my/nix-commit

** My notes

#+begin_src emacs-lisp
  (defun my/quick-commit (message)
    "Commit all files in my notes with MESSAGE"
    (interactive
     (list (read-string "Commit message: " nil nil nil)))
    (let* ((default-directory (my/get-project-path "notes"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*notes-commit*"))))
      (compile (format "git add . ; git commit -m %s ; git pull ; git push" message) t)))
#+end_src

#+RESULTS:
: my/nix-commit

** Bitwarden Clients

#+begin_src emacs-lisp
  (defun bitwarden/clients/npm/ci-run ()
    "Run the typeschecker for the clients monorepo"
    (interactive)
    (let* ((default-directory (my/get-project-path "clients"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*clients-typechecker*"))))
      (compile "npm ci" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/clients/typechecker/run ()
    "Run the typeschecker for the clients monorepo"
    (interactive)
    (let* ((default-directory (my/get-project-path "clients"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*clients-typechecker*"))))
      (compile "npm run test:types" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/clients/browser/chrome/run ()
    "Watch a chrome dev build of the extension"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "clients") "/apps/browser"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*clients-browser-chrome-run*"))))
      (compile "npm run build:watch:chrome" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/clients/web/run ()
    "Watch a build of the web vault"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "clients") "/apps/web"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*clients-web-run*"))))
      (compile "npm run build:watch" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/server/api/run ()
    "Watch a build of the bitwarden server api"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "server") "/src/Api"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*bitwarden-server-api-run*"))))
      (compile "dotnet run" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/server/identity/run ()
    "Watch a build of the bitwarden server identity"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "server") "/src/Identity"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*bitwarden-server-identity-run*"))))
      (compile "dotnet run" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/server/identity/run ()
    "Watch a build of the bitwarden server identity"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "server") "/src/Identity"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*bitwarden-server-identity-run*"))))
      (compile "dotnet run" t)))
#+end_src

#+begin_src emacs-lisp
  (defun bitwarden/server/run-sql ()
    "Watch a build of the bitwarden server identity"
    (interactive)
    (let* ((default-directory (concat (my/get-project-path "server") "/src/dev"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) (format "*bitwarden-server-identity-run*"))))
      (compile "dotnet run" t)))
#+end_src

#+begin_src emacs-lisp 
  (defun bitwarden/clients/run-tests (&optional test-pattern)
    "Run Jest tests for the clients monorepo.
  If TEST-PATTERN is provided, filter tests using the -t option."
    (interactive "sTest pattern (optional): ")
    (let* ((default-directory (my/get-project-path "clients"))
	   (command (if (and test-pattern (not (string-empty-p test-pattern)))
			(format "npm run test:watch -- -t '%s'" test-pattern)
		      "npm run test:watch"))
	   (buffer-name (if (and test-pattern (not (string-empty-p test-pattern)))
			    (format "*clients-jest-%s*" test-pattern)
			  "*clients-jest*"))
	   (compilation-buffer-name-function 
	    (lambda (_mode) buffer-name)))
      (compile command t)))
#+end_src

*** Run typechecking

* Custom Keymaps

#+begin_src emacs-lisp
(define-prefix-command 'my-custom-prefix)
(evil-define-key 'normal 'global (kbd "C-a") 'my-custom-prefix)
(which-key-add-key-based-replacements "C-a" "my commands")

;; create "go" prefix map
(define-prefix-command 'my-go-prefix)
(evil-define-key 'normal 'global (kbd "C-a g") 'my-go-prefix)
(which-key-add-key-based-replacements "C-a g" "go")

(defun my/open-compilation-file-in-other-window ()
  "open the current compilation match in another window.
creates a new window if needed or reuses an existing one."
  (interactive)
  (let ((window-count (length (window-list))))
    (condition-case err
        (if (= window-count 1)
            ;; only one window, use built-in function that creates a new window
            (compilation-display-error)
          ;; multiple windows exist, use the next window
          (let ((this-window (selected-window)))
            (other-window 1)
            (let ((target-window (selected-window)))
              (select-window this-window)
              ;; use next-error-no-select to get location without changing windows
              (let ((location (next-error-no-select)))
                (select-window target-window)
                (switch-to-buffer (marker-buffer (car location)))
                (goto-char (marker-position (car location)))))))
      ;; catch any errors silently
      (error (message "no valid location found at point")))))

(evil-define-key 'normal 'global (kbd "C-a g f") 'my/open-compilation-file-in-other-window)
(which-key-add-key-based-replacements "C-a g f" "go to file")

(evil-define-key 'normal 'global (kbd "C-a g d") 'lsp-find-definition)
(which-key-add-key-based-replacements "C-a g d" "go to definition")
(evil-define-key 'normal 'global (kbd "C-a g e") (lambda () (interactive) (find-file "/users/me/nix/system/with/user/with/program/emacs.org")))
(which-key-add-key-based-replacements "C-a g e" "emacs config")

(define-prefix-command 'my-compile-prefix)
(evil-define-key 'normal 'global (kbd "C-a c") 'my-compile-prefix)
(which-key-add-key-based-replacements "C-a c" "compile")

(define-prefix-command 'my-nix-compile-prefix)
(evil-define-key 'normal 'global (kbd "C-a c n") 'my-nix-compile-prefix)
(which-key-add-key-based-replacements "C-a c n" "nix")

(evil-define-key 'normal 'global (kbd "C-a c n r") 'my/nix-rebuild)
(which-key-add-key-based-replacements "C-a c n r" "rebuild")

(evil-define-key 'normal 'global (kbd "C-a c n f") 'my/nix-format)
(which-key-add-key-based-replacements "C-a c n f" "format")

(evil-define-key 'normal 'global (kbd "C-a c n c") 'my/nix-commit)
(which-key-add-key-based-replacements "C-a c n c" "commit")

;; create "find" prefix map
(define-prefix-command 'my-find-prefix)
(evil-define-key 'normal 'global (kbd "C-a f") 'my-find-prefix)
(which-key-add-key-based-replacements "C-a f" "find")

(evil-define-key 'normal 'global (kbd "C-a f g") 'projectile-ripgrep)
(which-key-add-key-based-replacements "C-a f g" "ripgrep")

(evil-define-key 'normal 'global (kbd "C-a f p") 'projectile-switch-project)
(which-key-add-key-based-replacements "C-a f p" "project")

(evil-define-key 'normal 'global (kbd "C-a f f") 'find-file)
(which-key-add-key-based-replacements "C-a f f" "file in directory")

(evil-define-key 'normal 'global (kbd "C-a f F") 'projectile-find-file)
(which-key-add-key-based-replacements "C-a f F" "file in project")

(evil-define-key 'normal 'global (kbd "C-a f b") 'consult-buffer)
(which-key-add-key-based-replacements "C-a f b" "find an open buffer")

(evil-define-text-object evil-inner-org-src-block (count &optional beg end type)
  "Select an org source block, excluding the begin/end lines."
  (when (org-in-src-block-p)
    (save-excursion
      (let* ((element (org-element-at-point))
             (begin (org-element-property :begin element))
             (end (org-element-property :end element))
             (begin-adjusted (progn
                               (goto-char begin)
                               (forward-line 1)
                               (point))))
        (goto-char begin)
        (re-search-forward "^[ \t]*#\\+end_src" end t)
        (forward-line -1)
        (let ((end-adjusted (line-end-position)))
          (evil-range begin-adjusted end-adjusted 'line))))))

(evil-define-text-object evil-a-org-src-block (count &optional beg end type)
  "Select an org source block, including the begin/end lines."
  (when (org-in-src-block-p)
    (save-excursion
      (let* ((element (org-element-at-point))
             (begin (org-element-property :begin element))
             (end (org-element-property :end element)))
        (evil-range begin end 'line)))))

(evil-define-key 'operator org-mode-map (kbd "is") 'evil-inner-org-src-block)
(evil-define-key 'operator org-mode-map (kbd "as") 'evil-a-org-src-block)
(which-key-add-key-based-replacements "is" "inside src block")
(which-key-add-key-based-replacements "as" "around src block")

(evil-define-key 'normal 'global (kbd "C-l") 'gptel-menu)
(evil-define-key 'normal 'global (kbd "U") 'undo-redo)

(defun my/org-agenda-daily-dashboard ()
  "Open the custom 'daily dashboard' org-agenda view."
  (interactive)
  (org-agenda nil "d"))

(evil-define-key 'normal 'global (kbd "C-o") 'my/org-agenda-daily-dashboard)
(evil-define-key 'normal 'global (kbd "D") 'kill-buffer)
(evil-define-key 'normal magit-mode-map (kbd "C-d") 'kill-buffer)

(evil-define-key 'normal 'global (kbd "C-e") 'elfeed)
(evil-define-key 'normal elfeed-search-mode-map (kbd "C-r") 'elfeed-update)

(evil-define-key 'normal 'global (kbd "<f6>") 'my/toggle-theme)

(evil-define-key 'normal 'global (kbd "C-z") 'magit-status)

(with-eval-after-load 'elfeed-show
  (require 'hnreader)
  (require 'evil)

  (defun my/elfeed-show-hn-comments ()
    "Open Hacker News comments for the link at point in elfeed-show-mode."
    (interactive)
    (message "my/elfeed-show-hn-comments invoked.")
    (let ((link (elfeed-get-link-at-point)))
      (message "Link at point: %s" link)
      ;; Check if it's a valid HN item link
      (if (and link (string-match "news\\.ycombinator\\.com/item\\?id=[0-9]+" link))
          (progn ;; Use progn to execute multiple forms
            (message "Found HN link: %s. Calling hnreader-comment..." link)
            ;; Pass the full link URL to hnreader-comment
            (hnreader-comment link)
            (message "hnreader-comment called with URL."))
        (message "No Hacker News item link found at point or link doesn't match pattern."))))

  (evil-define-key 'normal elfeed-show-mode-map
    (kbd "c") #'my/elfeed-show-hn-comments))

;;(defun my/open-ripgrep-result-in-split ()
 ;; "Open the ripgrep result at point in a vertical split."
  ;;(interactive)
  ;;(let ((window-count (length (window-list))))
   ;; (when (= window-count 1)
    ;;  (split-window-right))
    ;;(other-window 1)
    ;;(compile-goto-error)))

;;(with-eval-after-load 'rg
  ;;(evil-define-key 'normal rg-mode-map (kbd "RET") 'my/open-ripgrep-result-in-split))

;;;(evil-define-key 'normal 'global (kbd "C-b") 'projectile-switch-to-buffer)
;;(evil-define-key 'normal 'global (kbd "C-p") 'projectile-switch-project)
;;(evil-define-key 'normal 'global (kbd "C-f") 'projectile-find-file)
;;(evil-define-key 'normal magit-mode-map (kbd "C-b") 'projectile-switch-to-buffer)
;;(evil-define-key 'normal magit-mode-map (kbd "C-p") 'projectile-switch-project)
;;(evil-define-key 'normal magit-mode-map (kbd "C-f") 'projectile-find-file)

(evil-global-set-key 'normal (kbd "C-b") 'projectile-switch-to-buffer)
(evil-global-set-key 'normal (kbd "C-p") 'projectile-switch-project)
(evil-global-set-key 'normal (kbd "C-f") 'projectile-find-file)
(evil-define-key 'normal magit-mode-map (kbd "C-b") 'projectile-switch-to-buffer)
(evil-define-key 'normal magit-mode-map (kbd "C-p") 'projectile-switch-project)
(evil-define-key 'normal magit-mode-map (kbd "C-f") 'projectile-find-file)
(evil-define-key 'normal vterm-mode-map (kbd "C-b") 'projectile-switch-to-buffer)
(evil-define-key 'normal vterm-mode-map (kbd "C-p") 'projectile-switch-project)
(evil-define-key 'normal vterm-mode-map (kbd "C-f") 'projectile-find-file)

(defun clean-notes-buffer ()
  "Clean up a notes buffer by:
  1. Deleting lines starting with '- State'
  2. Removing extra blank lines
  3. Converting '- Note taken on [DATE] \\' to '** [DATE]'
  4. Removing all indentation from the buffer"
  (interactive)
  (save-excursion
    ;; Go to beginning of buffer
    (goto-char (point-min))
    
    ;; Delete lines starting with "- State"
    (while (re-search-forward "^- State.*$" nil t)
      (replace-match ""))
    
    ;; Clean up consecutive blank lines
    (goto-char (point-min))
    (while (re-search-forward "^\n\\s-*\n" nil t)
      (replace-match "\n"))
    
    ;; Convert note lines to new format (fixed to handle backslashes properly)
    (goto-char (point-min))
    (while (re-search-forward "^- Note taken on \\(\\[[0-9-]+ [A-Za-z]+\\( [0-9:]+\\)?\\]\\)\\s-*\\\\\\\\.*$" nil t)
      (replace-match "** \\1"))
    
    ;; Remove all indentation (leading spaces/tabs) from all lines
    (goto-char (point-min))
    (while (re-search-forward "^[ \t]+" nil t)
      (replace-match "")))
  (message "Notes cleanup completed!"))

(defun my/add-tag-to-headings-in-region (tag)
  "Add TAG to all org headings in the selected region."
  (interactive "sTag to add: ")
  (save-excursion
    (let ((end-marker (copy-marker (region-end)))
          (pos (region-beginning)))
      (goto-char pos)
      (while (and (< (point) end-marker)
                  (re-search-forward "^\\*+ " end-marker t))
        (org-set-tags (cons tag (org-get-tags)))
        (outline-next-heading)))))

(defun my/projectile-find-file-in-all-projects ()
  "Find file across all registered Projectile projects with improved performance."
  (interactive)
  (let* ((projects (projectile-relevant-known-projects))
         (file-cache-var 'my/projectile-all-files-cache)
         (cache-validity-seconds 300) ;; 5 minute cache validity
         (current-time (current-time))
         (use-cache (and (boundp file-cache-var)
                         (< (float-time (time-subtract 
                                         current-time
                                         (get file-cache-var 'timestamp)))
                            cache-validity-seconds)))
         (cached-files (and use-cache (symbol-value file-cache-var))))
    
    (if use-cache
        (message "Using cached file list (%d files)" (length cached-files))
      ;; Build cache using external commands for speed
      (message "Building file list from %d projects..." (length projects))
      (let ((all-files '())
            (temp-file (make-temp-file "projectile-files-")))
        ;; Using external find/sort is much faster than pure elisp
        (with-temp-file temp-file
          (dolist (project projects)
            (when (file-exists-p project)
              (let* ((project-name (file-name-nondirectory 
                                    (directory-file-name project)))
                     ;; Add project name prefix to each file for context
                     (cmd (format "cd %s && find . -type f -not -path \"*/\\.*\" | sort | sed 's|^\\.|%s:|'"
                                  (shell-quote-argument project)
                                  project-name)))
                (call-process-shell-command cmd nil t)))))
        
        ;; Read results back and build alist of (display . filepath)
        (with-temp-buffer
          (insert-file-contents temp-file)
          (goto-char (point-min))
          (while (not (eobp))
            (let* ((line (buffer-substring-no-properties (point) (line-end-position)))
                   ;; Fix: Only split on the first colon
                   (split-pos (string-match ":" line))
                   (project-name (when split-pos (substring line 0 split-pos)))
                   (rel-file (when split-pos (substring line (1+ split-pos))))
                   (full-path (when (and project-name rel-file)
                                (expand-file-name
                                 (string-remove-prefix "./" rel-file)
                                 (car (seq-filter (lambda (p) 
                                                    (string-suffix-p project-name p))
                                                  projects))))))
              (when (and project-name rel-file full-path)
                (push (cons (concat project-name ":" rel-file) full-path) all-files)))
            (forward-line 1)))
        
        (delete-file temp-file)
        ;; Save and timestamp the cache
        (set file-cache-var all-files)
        (put file-cache-var 'timestamp current-time)
        (message "Found %d files across projects" (length all-files))))
    
    ;; Use the cached or newly-built list
    (let ((file-list (if use-cache cached-files (symbol-value file-cache-var))))
      (if file-list
          ;; Use completing-read for the selection interface
          (let* ((chosen (completing-read "Find file in projects: " 
                                         (mapcar #'car file-list) nil t))
                 (file-path (cdr (assoc chosen file-list))))
            (when file-path
              (find-file file-path)))
        (message "No files found across projects")))))

(defun my/wikipedia-search-to-org (search-term)
  "Search Wikipedia for SEARCH-TERM, fetch the first result,
and display its content converted to Org format in a new buffer.
Requires `pandoc` to be installed."
  (interactive "sSearch Wikipedia for: ")
  (unless (executable-find "pandoc")
    (error "pandoc executable not found. Please install pandoc."))

  (require 'json)
  (require 'url)

  (let* ((encoded-search-term (url-hexify-string search-term))
         (search-api-url (format "https://en.wikipedia.org/w/api.php?action=opensearch&search=%s&limit=1&namespace=0&format=json"
                                 encoded-search-term))
         search-json-string search-data page-title page-url html-content org-output org-buffer-name)

    (with-current-buffer (url-retrieve-synchronously search-api-url)
      (goto-char (point-min))
      (unless (re-search-forward "\n\n" nil t) ; Skip HTTP headers
        (kill-buffer (current-buffer))
        (error "Could not find HTTP headers in Wikipedia API response"))
      (setq search-json-string (buffer-substring-no-properties (point) (point-max)))
      (kill-buffer (current-buffer)))

    (unless (and search-json-string (not (string-empty-p search-json-string)))
      (error "Failed to fetch or empty search results from Wikipedia API for: %s" search-term))

    (condition-case err
        ;; Explicitly use :array-type 'list to ensure lists are returned
        (setq search-data (json-parse-string search-json-string :array-type 'list))
      (error (error "Failed to parse JSON: %s. JSON was: %s" (error-message-string err) search-json-string)))

    ;; Now the checks should work as expected with lists
    (unless (and (listp search-data)
                 (>= (length search-data) 4)
                 (listp (nth 1 search-data)) (consp (nth 1 search-data)) ; Ensure titles list is non-empty
                 (stringp (car (nth 1 search-data))) ; Ensure first title is a string
                 (listp (nth 3 search-data)) (consp (nth 3 search-data)) ; Ensure URLs list is non-empty
                 (stringp (car (nth 3 search-data)))) ; Ensure first URL is a string
      (error "Unexpected JSON structure, empty result, or non-string title/URL from Wikipedia API. Data: %S" search-data))

    (setq page-title (car (nth 1 search-data)))
    (setq page-url (car (nth 3 search-data)))

    (with-current-buffer (url-retrieve-synchronously page-url)
      (goto-char (point-min))
      (unless (re-search-forward "\n\n" nil t) ; Skip HTTP headers
        (kill-buffer (current-buffer))
        (error "Could not find HTTP headers in Wikipedia page response for %s" page-url))
      (setq html-content (buffer-substring-no-properties (point) (point-max)))
      (kill-buffer (current-buffer)))

    (unless (and html-content (not (string-empty-p html-content)))
      (error "Failed to fetch or empty page content from URL: %s" page-url))

    (setq org-output
          (with-temp-buffer
            (insert html-content)
            (shell-command-on-region (point-min) (point-max)
                                     "pandoc -f html -t org --wrap=none"
                                     (current-buffer) t) ; t to replace
            (buffer-string)))

    (if (or (null org-output) (string-empty-p org-output))
        (error "Pandoc conversion resulted in empty output for %s" page-title)
      (setq org-buffer-name (format "*Wikipedia: %s (Org)*" page-title))
      (with-current-buffer (get-buffer-create org-buffer-name)
        (erase-buffer)
        (insert org-output)
        (when (fboundp 'org-mode) (org-mode))
        (goto-char (point-min)))
      (switch-to-buffer-other-window org-buffer-name)
      (message "Wikipedia page '%s' rendered as Org." page-title))))

(defun my/org-refile-to-new-file ()
  "Refile current heading to a new file named after the heading."
  (interactive)
  (let* ((heading (nth 4 (org-heading-components)))
         (safe-name (downcase (replace-regexp-in-string "[^a-zA-Z0-9]+" "-" heading)))
         (new-file (concat (file-name-as-directory org-directory) safe-name ".org")))
    (when (y-or-n-p (format "Create and refile to %s? " new-file))
      (with-temp-buffer
        (write-file new-file))
      (org-refile nil nil (list heading new-file nil nil)))))

(defun my/open-pr-url-at-point ()
  "Open the PR_URL property of the current org agenda item."
  (interactive)
  (let* ((marker (or (org-get-at-bol 'org-marker)
                     (org-agenda-error)))
         (buffer (marker-buffer marker))
         (pos (marker-position marker))
         url)
    (with-current-buffer buffer
      (save-excursion
        (goto-char pos)
        (setq url (org-entry-get (point) "PR_URL"))))
    (when url
      (browse-url url))))

;; Bind it to a key in org-agenda-mode-map
(define-key org-agenda-mode-map (kbd "C-c u") 'open-pr-url-at-point)
#+end_src
#+RESULTS:

* Provide Init

#+begin_src emacs-lisp
  (provide 'init)

  ;; Local Variables:
  ;; byte-compile-warnings: (not free-vars)
  ;; End:
		    ;;; init.el ends here
#+end_src

