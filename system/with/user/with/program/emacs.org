#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle init.el :results none

* TODO Track the full moon in my org agenda
:LOGBOOK:
CLOCK: [2025-03-02 Sun 19:34]--[2025-03-02 Sun 21:49] =>  2:15
:END:
* TODO Get mail working in emacs
* TODO Get time clocking working in emacs
* TODO Get LSP and code editing working better in emacs
* TODO Get emacs autosave working
* TODO Connect images to the take a picture agenda item 
* TODO Fix GPTel's write tools

* Bootstrap
#+begin_src emacs-lisp
  ;; init.el --- My personal Emacs configuration  -*- lexical-binding: t -*-

  ;; Commentary:
  ;; This is my personal Emacs configuration file.
  ;; It sets up various packages and configurations for development work.

  ;; Code:
#+end_src

* Initialize Package Sources
#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			   ("org" . "https://orgmode.org/elpa/")
			   ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Initialize use-package
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* UI Configuration

#+begin_src emacs-lisp
  ;; Configure frame appearance
  (setq default-frame-alist
	'((menu-bar-lines . 0)
	  (tool-bar-lines . 0)
	  (vertical-scroll-bars)
	  (left-fringe . 0)
	  (right-fringe . 0)
	  (internal-border-width . 0)
	  (undecorated . t)
	  (fullscreen . maximized)))

  (setq inhibit-startup-message t)
  (setq initial-frame-alist default-frame-alist)
  (setq-default mode-line-format nil)
  (advice-add #'display-startup-echo-area-message :override #'ignore)
#+end_src

* Basic Settings
#+begin_src emacs-lisp
  ;; Disable backup files and configure indentation
  (setq make-backup-files nil)
  (setq-default indent-tabs-mode nil)
  (electric-indent-mode 1)
  (setq-default tab-width 2
		indent-tabs-mode nil
		tab-stop-list (number-sequence 2 120 2))
  (setq confirm-kill-emacs nil)
  (setq auto-save-default nil
	create-lockfiles nil)
  (setq select-enable-clipboard t)
  (setq case-fold-search t)
  (xterm-mouse-mode 1)
  (setq-default fill-column 77)
  (global-hl-line-mode -1)
  (setq sentence-end-double-space nil)
#+end_src

* Buffer Management Functions
#+begin_src emacs-lisp
  (defun kill-other-buffers ()
    "Kill all buffers except the current one."
    (interactive)
    (mapc 'kill-buffer
	  (delq (current-buffer)
		(buffer-list))))

  (defun my/delete-this-file ()
    "Delete the current file and kill its buffer."
    (interactive)
    (let ((file (buffer-file-name)))
      (when (and file
		 (y-or-n-p (format "Delete %s?" file)))
	(delete-file file)
	(kill-buffer)
	(message "Deleted %s" file))))
#+end_src

* Package Management
#+begin_src emacs-lisp
  (require 'package)

  ;; Use Package Configuration
  (use-package nerd-icons)

  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (when (daemonp)
    (exec-path-from-shell-initialize))
#+end_src

* Dashboard Configuration
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :init
    (setq dashboard-icon-type 'nerd-icons)
    (setq dashboard-projects-backend 'projectile)
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-center-content t
         dashboard-items '((recents . 5)
                           (projects . 5)
                           (bookmarks . 5))
         dashboard-set-heading-icons t
         dashboard-set-file-icons t
         dashboard-show-shortcuts t
         dashboard-set-navigator t)
    (setq dashboard-heading-icons '((recents   . "nf-oct-history")
                                   (bookmarks . "nf-oct-bookmark")
                                   (projects  . "nf-oct-project"))))
#+end_src

* Font Configuration
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :family "Iosevka" :height 140)
  (set-face-attribute 'variable-pitch nil :family "Iosevka Etoile" :height 100)
#+end_src

* Evil Mode Configuration
#+begin_src emacs-lisp
  ;; Test
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)

  (use-package evil
    :ensure t
    :config
    (evil-mode 1)

    ;; Custom movement functions
    (defun evil-move-half-page-down ()
      "Move cursor half page down"
      (interactive)
      (evil-next-line (/ (window-height) 4))
      (evil-scroll-line-to-center nil))

    (defun evil-move-half-page-up ()
      "Move cursor half page up"
      (interactive)
      (evil-previous-line (/ (window-height) 4))
      (evil-scroll-line-to-center nil))

    ;; Bind J and K to half-page movement
    (define-key evil-normal-state-map (kbd "J") 'evil-move-half-page-down)
    (define-key evil-normal-state-map (kbd "K") 'evil-move-half-page-up))

  (use-package evil-collection
    :ensure t
    :after evil
    :config
    (evil-collection-init))

  ;; Configure evil-collection for magit
  (with-eval-after-load 'evil-collection-magit
    (evil-collection-define-key 'normal 'magit-status-mode-map
				"V" #'magit-start-region-select))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  (evil-define-key 'motion org-agenda-mode-map
		   (kbd "<left>") 'org-agenda-earlier
		   (kbd "<right>") 'org-agenda-later
		   (kbd "C-c j") 'org-agenda-goto-date
		   (kbd "gx")  'org-agenda-open-link
		   (kbd "t") 'org-agenda-todo
		   (kbd "T") 'org-agenda-todo-yesterday)
#+end_src

* Server Configuration
#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

* Project Management
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (define-key projectile-command-map (kbd "d") 'projectile-find-file-in-directory)
    ;; Specify known projects
    (setq projectile-known-projects
	  (mapcar 'expand-file-name
		  '("~/notes"
		    "~/nix"
		    "~/bitwarden/clients"
		    "~/bitwarden/server"
		    "~/bitwarden/sdk"
		    "~/bitwarden/sdk-internal"
		    "~/bitwarden/wg-open-source-at-bitwarden"
		    "~/bitwarden/contributing-docs"
		    "~/code"
		    "~/d"
		    "~/binwarden"
		    "~/recipes")))
    ;; Disable auto-discovery
    (setq projectile-auto-discover nil)
    ;; Save the project list immediately
    (projectile-save-known-projects)
    :bind-keymap
    ("C-c p" . projectile-command-map))
#+end_src

* Completion Framework
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles . (partial-completion))))))

  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))

  (use-package consult
    :ensure t
    :bind
    (("C-s" . consult-line)
     ("C-c b" . consult-buffer)
     ("C-c f" . consult-find)
     ("C-c r" . consult-ripgrep)))

  ;; Custom find-from-here function
  (defun find-from-here ()
    "Find files from current buffer's directory."
    (interactive)
    (when buffer-file-name
      (consult-find (file-name-directory buffer-file-name))))

  (global-set-key (kbd "C-c d") 'find-from-here)
#+end_src

* Tree-sitter Configuration
#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :config
    (global-treesit-auto-mode)
    (setq treesit-auto-install 'prompt)
    (setq treesit-auto-langs '(typescript javascript tsx jsx)))

(use-package typescript-ts-mode
    :ensure t
    :mode (("\\.ts\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode))
    :init
    (add-to-list 'major-mode-remap-alist '(typescript-mode . typescript-ts-mode))
    (add-to-list 'major-mode-remap-alist '(tsx-mode . tsx-ts-mode)))

;; Ensure typescript grammar is installed
(unless (treesit-language-available-p 'typescript)
  (treesit-install-language-grammar 'typescript))
#+end_src

* LSP Configuration
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :hook ((typescript-ts-mode . lsp)
           (tsx-ts-mode . lsp)
	   (typescript-mode . lsp)
	   (csharp-mode . lsp)
	   (rust-mode . lsp)
	   (nix-mode . lsp)
	   (json-mode . lsp)
	   (sql-mode . lsp)
	   (lua-mode . lsp))
    :commands lsp
    :config
    ;;(setq lsp-nix-nixd-server-path "nixd")
    ;;(setq lsp-enabled-clients '(nixd-lsp))
    (setq lsp-auto-guess-root t)
    (setq lsp-enable-symbol-highlighting t)
    (setq lsp-enable-on-type-formatting t)
    (setq lsp-modeline-code-actions-enable t)
    (setq lsp-modeline-diagnostics-enable t)
    (setq lsp-diagnostics-provider :flycheck)
    (setq lsp-ui-doc-enable t)
    (setq lsp-ui-doc-show-with-cursor t)
    (add-to-list 'lsp-disabled-clients 'copilot-ls)
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\chats\\'")
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-headerline-breadcrumb-mode nil)
    (lsp-enable-which-key-integration t))

  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode)

  ;; Company mode for completions
  (use-package company
    :ensure t
    :config
    (setq company-minimum-prefix-length 1
	  company-idle-delay 0.0))

  ;; Add flycheck configuration
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode))
#+end_src

* Magit and Forge Configuration
#+begin_src emacs-lisp
  (defun magit-status-project ()
    "Switch project and open magit."
    (interactive)
    (let ((projectile-switch-project-action 'magit-status))
      (projectile-switch-project)))

  (global-set-key (kbd "C-c m") 'magit-status-project)

  (use-package forge
    :ensure t
    :after magit
    :config
    ;; Configure GitHub authentication
    (setq auth-sources '("~/.authinfo"))
    ;; Optionally set the number of items to fetch
    (setq forge-topic-list-limit '(60 . 0)))
#+end_src

* Basic Settings and Markdown Configuration
#+begin_src emacs-lisp
  ;; Basic settings
  (setq notes-directory "~/notes")
  (setq markdown-command "pandoc")

  ;; Markdown configuration
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode)))
#+end_src

* Org Mode Configuration 
#+begin_src emacs-lisp
  ;; Basic org settings
  (use-package org
    :ensure t
    :bind
    (("C-c a" . org-agenda)
     ("C-c h" . consult-org-heading)
     ("C-c c" . org-capture))
    :config
    (setq org-directory "~/notes")
    (setq org-startup-truncated nil)
    (setq org-agenda-files (list org-directory))
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-startup-folded 'overview)
    (setq org-clock-persist 'history
    org-export-backends '(html icalendar latex man md org)
    org-clock-idle-time 15
    org-clock-persist-file "~/notes/clock.el"
    org-clock-auto-clock-resolution 'when-no-clock-is-running
    org-clock-report-include-clocking-task t
    org-clock-into-drawer t)
    (org-clock-persistence-insinuate))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (org . t)
     ))

  (setq org-babel-sh-command "bash -l -c")

  ;; Allow evaluation of code blocks without confirmation for safe languages
  (defun my/org-confirm-babel-evaluate (lang body)
    (not (member lang '("emacs-lisp" "shell"))))
  ;;(setq org-confirm-babel-evaluate 'my/org-confirm-babel-evaluate)
  (setq org-confirm-babel-evaluate nil)

  ;; Ensure pretty fontification of source blocks
  (setq org-src-fontify-natively t)
  (define-key org-mode-map (kbd "RET") 'newline)

  ;; These bindings just emulate the defaults instead of doing a bunch of weird org specific stuff.
  (evil-define-key 'insert org-mode-map (kbd "RET") 'newline)
  (evil-define-key 'insert org-mode-map (kbd "TAB") 'tab-to-tab-stop)
  (defun my-org-evil-open-below ()
   "Open line below preserving org structure but preventing reformatting."
   (interactive)
   ;; Use evil's basic open behavior
   (evil-open-below 1)
   ;; Exit insert state then re-enter to avoid auto-formatting
   (evil-normal-state)
   (evil-insert-state))

  (evil-define-key 'normal org-mode-map "o" 'my-org-evil-open-below)

  ;;(require 'ob-async) ;; Allow for asyncround running of babel blocks
#+end_src

* Org To Jira
#+begin_src emacs-lisp :tangle no
(use-package ox-jira
  :ensure t
  :after org)
#+end_src
* Org Capture Templates and Functions
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("i" "Inbox" entry
           (file "~/notes/inbox.org")
           "* TODO %^{Title}\nSCHEDULED: %t\n%?")))
#+end_src

* Date Tracking Functions

I'm not using these right now, but might revist in the future.

#+begin_src emacs-lisp :tangle no
  ;; Date tracking functions
  (defun my/org-set-completed-date ()
    (when (equal "Done" (org-entry-get nil "STATUS"))
      (org-entry-put nil "COMPLETED"
		     (format-time-string "[%Y-%m-%d %a]"))))

  (defun my/org-set-started-date ()
    (when (equal "In-Progress" (org-entry-get nil "STATUS"))
      (org-entry-put nil "STARTED"
		     (format-time-string "[%Y-%m-%d %a]"))))

  (add-hook 'org-property-changed-functions
	    (lambda (property value)
	      (when (equal property "STATUS")
		(my/org-set-completed-date)
		(my/org-set-started-date))))
#+end_src

* Conversion Functions
#+begin_src emacs-lisp
  (defun convert-to-org ()
    "Convert current markdown buffer to org format."
    (interactive)
    (let* ((md-file (buffer-file-name))
	   (org-file (concat (file-name-sans-extension md-file) ".org")))
      (when (and md-file (file-exists-p md-file))
	(call-process "pandoc" nil nil nil
		      "-f" "markdown"
		      "-t" "org"
		      md-file
		      "-o" org-file)
	(find-file org-file))))

  (defun convert-to-markdown ()
    "Convert current org buffer to markdown format."
    (interactive)
    (let* ((org-file (buffer-file-name))
	   (md-file (concat (file-name-sans-extension org-file) ".md")))
      (when (and org-file (file-exists-p org-file))
	(call-process "pandoc" nil nil nil
		      "-f" "org"
		      "-t" "markdown"
		      org-file
		      "-o" md-file)
	(find-file md-file))))

  (with-eval-after-load 'markdown-mode
    (define-key markdown-mode-map (kbd "C-c C-o") 'convert-to-org))

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c C-m") 'convert-to-markdown))

  (defun my/move-to-custom-id-file ()
    "Move selected org item to a new file named after its CUSTOM_ID property."
    (interactive)
    (save-excursion
      (let* ((region-content (buffer-substring (region-beginning) (region-end)))
	     (custom-id (save-excursion
			  (goto-char (region-beginning))
			  (org-entry-get nil "CUSTOM_ID"))))
	(if custom-id
	    (let ((new-file (concat "~/notes/" custom-id ".org")))
	      (with-temp-file new-file
		(insert "#+TITLE: " custom-id "\n\n")
		(insert region-content))
	      (delete-region (region-beginning) (region-end))
	      (insert (format "[[file:%s][%s]]\n" new-file custom-id))
	      (message "Moved to %s" new-file))
	  (message "No CUSTOM_ID property found!")))))
#+end_src

* Agenda Configuration
#+begin_src emacs-lisp
  (setq org-agenda-block-separator nil)
  (setq org-agenda-window-setup 'only-window)
  (setq org-agenda-timegrid-use-ampm t)
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-todo-keyword-format "%s")
  (setq org-agenda-include-diary t)
  (setq org-refile-targets '((nil :maxlevel . 8)
			     (org-agenda-files :maxlevel . 2)))
  
  ;; Allow creating new nodes (including new files) when refiling
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  
  ;; Use the full outline paths for refile targets
  (setq org-refile-use-outline-path 'file)
  
  ;; Completes in steps so you can select a heading after selecting the file
  (setq org-outline-path-complete-in-steps t)

  (require 'diary-lib)

  (use-package org-super-agenda
    :after org-agenda
    :config
    (setq org-super-agenda-header-map nil)  
    (setq org-super-agenda-header-properties nil)
    (org-super-agenda-mode))

  (setq warning-suppress-types '((org-element)))

  (setq org-agenda-custom-commands
	'(("d" "daily dashboard"
	   ((agenda "Schedule and Habits"
		    ((org-agenda-span 'day)
		     (org-agenda-sorting-strategy '((agenda time-up todo-state-down alpha-up)))
		     (org-agenda-overriding-header "")
		     (org-super-agenda-groups
		      '(
			(:name "Happening today" 
			       :and(:scheduled nil :deadline nil :not(:time-grid t)))
			(:name "Today's Schedule"
			       :time-grid t)
			(:name "Overdue" :deadline past)
			(:name "Due Today" :deadline today)
			(:name "High Priority" :priority "A")
			(:name "Inbox" :category "inbox")
			(:name "Logs" :category "log")
			(:name "Due Soon" :deadline future)
			(:name "Code Reviews" :category "code review")
			(:name "Active Epics" :category "epic")
			(:name "Family Stuff" :category "family")
			(:name "Holidays" :category "holiday")
			(:name "The Garden" :category "the-garden")
			(:name "Re: Me" :category "me")
			(:name "Re: Emily" :category "emily")
			(:name "Re: Lincoln" :category "lincoln")
			(:name "Re: Nora" :category "nora")
			(:name "Re: Fern" :category "fern")
			(:name "Re: Harry" :category "harry")
			(:name "AM Habits" :category "personal habits am")
			(:name "Midday Habits" :category "personal habits midday")
			(:name "PM Habits" :category "personal habits pm")
			(:name "Any Time Habits" :category "personal habits any time")
			(:name "Work Habits" :category "work habits")
			(:auto-category t)
			))))))))

  (setq org-agenda-time-grid-use-ampm t)
  (setq org-agenda-with-times t)
  (setq org-agenda-time-format "%I:%M%p")
  (setq org-agenda-prefix-format
	'((agenda . " ○ %t ")
	  (tags   . "○ ")
	  (todo   . "○ ")))
#+end_src

* Org Face Customizations
#+begin_src emacs-lisp
  ;; Face customizations for org mode
  (custom-set-faces
   '(org-document-info-keyword ((t (:height 1.0))))
   '(org-document-title ((t (:height 140))))
   '(org-level-1 ((t (:height 140))))
   '(org-level-2 ((t (:height 140))))
   '(org-level-3 ((t (:height 140))))
   '(org-level-4 ((t (:height 140))))
   '(org-level-5 ((t (:height 140))))
   '(org-level-6 ((t (:height 140))))
   '(org-level-7 ((t (:height 140))))
   '(org-level-8 ((t (:height 140))))
   '(org-modern-label ((t (:height 140))))
   '(org-modern-statistics ((t (:height 140))))
   '(org-modern-tag ((t (:height 140))))
   '(org-drawer ((t (:height 140))))
   '(org-drawer-content ((t (:height 140))))
   '(variable-pitch-text ((t (:height 140))))
   '(variable-pitch ((t (:height 140))))
   '(org-property-value ((t (:height 140))))
   '(org-special-keyword ((t (:height 140)))))
#+end_src

* GitHub Integration
#+begin_src emacs-lisp
  (require 'ghub)

  (defvar my/github-pr-file "~/notes/code-reviews.org"
    "File to store GitHub PR todos.")

  (defvar my/github-pr-queries
    '(("Involved PRs" . "is:open is:pr involves:addisonbeck -author:addisonbeck")))

  (defun my/pr-exists-p (url)
    "Check if PR with URL already exists in the org file."
    (message "Checking for existing PR: %s" url)
    (when (file-exists-p my/github-pr-file)
      (message "File exists, checking content")
      (with-temp-buffer
	(insert-file-contents my/github-pr-file)
	(message "File contents loaded")
	;; Instead of using buffer positions, just check if the string exists
	(string-match-p (regexp-quote url) (buffer-string)))))

  (defun my/fetch-github-prs ()
    "Fetch PRs and create new org entries if they don't exist."
    (interactive)
    (message "Starting PR fetch")
    (let ((buf (find-file-noselect my/github-pr-file)))
      (message "Buffer created: %S" buf)
      (with-current-buffer buf
	(message "In buffer")
	(org-mode)
	(message "Org mode enabled")
	(let ((max-point (point-max)))
	  (message "Max point: %S" max-point)
	  (goto-char max-point)
	  (message "Moved to end of buffer")
	  (dolist (query-pair my/github-pr-queries)
	    (let* ((section-name (car query-pair))
		   (query (cdr query-pair)))
	      (message "Processing query: %s" section-name)
	      (let ((response (ghub-graphql
			       "query($query: String!) {
					      search(query: $query, type: ISSUE, first: 100) {
						nodes {
						  ... on PullRequest {
						    title
						    url
						    repository {
						      nameWithOwner
						    }
						    author {
						      login
						    }
						    updatedAt
						    state
						  }
						}
					      }
					    }"
			       `((query . ,query)))))
		(message "Got GraphQL response")
		(when-let ((prs (alist-get 'nodes (alist-get 'search (alist-get 'data response)))))
		  (message "Found %d PRs" (length prs))
		  (dolist (pr prs)
		    (message "Processing PR: %S" pr)
		    (let-alist pr
		      (message "Checking if PR exists: %s" .url)
		      (let ((exists-result (my/pr-exists-p .url)))
			(message "PR exists check returned: %S" exists-result)
			(unless exists-result
			  (message "PR doesn't exist, inserting")
			  (let ((insert-point (point)))
			    (message "Current point before insert: %S" insert-point)
			    (insert (format "* TODO %s\nSCHEDULED: <%s>\n:PROPERTIES:\n:PR_URL: %s\n:REPO: %s\n:AUTHOR: %s\n:END:\n"
					    .title
					    (format-time-string "%Y-%m-%d")
					    .url
					    .repository.nameWithOwner
					    .author.login))
			    (message "Insert completed"))))))))))))
      (message "Saving buffer")
      (save-buffer)
      (message "PR fetch completed")))

  (global-set-key (kbd "C-c g p") #'my/fetch-github-prs)

  (defun remove-duplicate-org-entries ()
    (interactive)
    (let ((seen-urls (make-hash-table :test 'equal)))
      (org-map-entries
       (lambda ()
	 (let ((pr-url (org-entry-get nil "PR_URL")))
	   (if (and pr-url (gethash pr-url seen-urls))
	       (org-cut-subtree)
	     (when pr-url
	       (puthash pr-url t seen-urls))))))))
#+end_src

* Which Key Configuration
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode)
    (setq which-key-idle-delay 0.3
	  which-key-prefix-prefix "→"
	  which-key-sort-order 'which-key-key-order-alpha
	  which-key-side-window-location 'bottom
	  which-key-side-window-max-height 0.25))
#+end_src

* Theme Configuration
#+begin_src emacs-lisp
    (use-package gruvbox-theme
      :ensure t
      :config
      (load-theme 'gruvbox-dark-hard t))

  (custom-set-faces
   `(org-warning ((t (:foreground ,(if (eq 'dark (frame-parameter nil 'background-mode))
                                      "#83a598"  ; gruvbox-dark blue
                                    "#076678")  ; gruvbox-light blue
                             ))))
   '(org-agenda-deadline-face ((t (:inherit org-warning :foreground nil :background nil :weight bold))))
   '(org-upcoming-deadline ((t (:inherit org-warning :foreground nil :background nil :weight bold))))
   '(org-scheduled-previously ((t (:inherit org-warning :foreground nil :background nil :weight normal))))
   )
#+end_src

* Elfeed Configuration
#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    ("C-x w" . elfeed)
    :config
    (evil-define-key 'normal elfeed-search-mode-map
		     (kbd "r") 'elfeed-search-untag-all-unread
		     (kbd "u") 'elfeed-search-tag-all-unread
		     (kbd "RET") 'elfeed-search-show-entry
		     (kbd "q") 'quit-window
		     (kbd "g") 'elfeed-update
		     (kbd "G") 'elfeed-search-update--force)

    (evil-define-key 'normal elfeed-show-mode-map
		     (kbd "r") 'elfeed-show-untag-unread
		     (kbd "u") 'elfeed-show-tag-unread
		     (kbd "q") 'quit-window
		     (kbd "n") 'elfeed-show-next
		     (kbd "p") 'elfeed-show-prev
		     (kbd "b") 'elfeed-show-visit)

    (setq elfeed-search-filter "+unread or +starred")
    (setq elfeed-sort-order 'descending))

  (use-package elfeed-protocol
    :ensure t
    :after elfeed
    :custom
    (elfeed-use-curl t)
    (elfeed-protocol-enabled-protocols '(fever))
    (setq elfeed-protocol-log-trace t)
    (elfeed-protocol-fever-update-unread-only t)
    (elfeed-protocol-fever-fetch-category-as-tag t)
    (elfeed-protocol-feeds '(("fever+https://me@rss.addisonbeck.dev"
			      :api-url "https://rss.addisonbeck.dev/api/fever.php"
			      :use-authinfo t)))
    (elfeed-protocol-enabled-protocols '(fever))
    :config
    (elfeed-protocol-enable))

  (defun my/elfeed-reset ()
    "Reset elfeed database and update."
    (interactive)
    (when (yes-or-no-p "Really reset elfeed database? ")
      (let ((db (expand-file-name "~/.elfeed/index"))
	    (data (expand-file-name "~/.elfeed/data")))
	(message "Checking paths: index=%s data=%s" db data)

	;; Try to close elfeed first
	(elfeed-db-unload)
	(message "Database unloaded")

	;; Delete files with error checking
	(condition-case err
	    (progn
	      (when (file-exists-p db)
		(delete-file db)
		(message "Deleted index file"))
	      (when (file-exists-p data)
		(delete-directory data t)
		(message "Deleted data directory")))
	  (error (message "Error during deletion: %s" err)))

	;; Restart elfeed
	(elfeed)
	(elfeed-search-update--force)
	(message "Reset complete"))))
#+end_src

* GPTel Configuration
#+begin_src emacs-lisp
    (use-package gptel
      :ensure t
      :config
      ;; Enable debug logging
      (setq gptel-log-level 'debug)

      ;; Use org-mode for gptel buffers
      (setq gptel-default-mode 'org-mode)
      ;; Enable branching conversations in org-mode
      (setq gptel-org-branching-context t)

      ;; Update prompt/response prefixes for org-mode to be compatible with branching conversations
      (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "@user\n")
      (setf (alist-get 'org-mode gptel-response-prefix-alist) "@assistant\n")

      ;; Token access for GitHub Copilot
      (defvar gptel-github-api-key
        (lambda ()
  	(when-let ((auth (car (auth-source-search
  			       :host "github.copilot"
  			       :require '(:secret)))))
  	  (let ((token (plist-get auth :secret)))
  	    (if (functionp token)
  		(funcall token)
  	      token)))))

      (defun gptel-copilot--exchange-token ()
        (let* ((github-token (if (functionp gptel-github-api-key)
  			       (funcall gptel-github-api-key)
  			     gptel-github-api-key))
  	     (url-request-method "GET")
  	     (url-request-extra-headers
  	      `(("Authorization" . ,(format "Bearer %s" github-token))
  		("Accept" . "application/json")))
  	     response-buffer token-str)
  	(setq response-buffer
  	      (url-retrieve-synchronously
  	       "https://api.github.com/copilot_internal/v2/token"
  	       t nil 30))
  	(when response-buffer
  	  (with-current-buffer response-buffer
  	    (goto-char (point-min))
  	    (when (re-search-forward "^$" nil t)
  	      (forward-char)
  	      (condition-case nil
  		  (let ((json-response (json-read)))
  		    (setq token-str (cdr (assoc 'token json-response))))
  		(error nil)))
  	    (kill-buffer response-buffer)))
  	token-str))

      ;; Store the exchanged token
      (defvar gptel-copilot--exchanged-token nil)
      (setq gptel-copilot--exchanged-token (gptel-copilot--exchange-token))

      ;; Update gptel-api-key to use the exchanged token
      (setq gptel-api-key
  	  (lambda ()
  	    (or gptel-copilot--exchanged-token
  		(setq gptel-copilot--exchanged-token
  		      (gptel-copilot--exchange-token)))))

      ;; Advice to include full path in message
      (defun gptel--insert-at-beginning-with-path (initial-point)
        "Include full path when showing buffer contents."
        (let ((full-path (buffer-file-name)))
  	(goto-char initial-point)
  	(insert
  	 (format "In file %s:\n\n"
  		 (if full-path
  		     (expand-file-name full-path)
  		   (buffer-name))))))

      (advice-add 'gptel--insert-at-beginning :override #'gptel--insert-at-beginning-with-path)

      ;; Create custom backend for GitHub Copilot
      (setq gptel-copilot-backend
  	  (gptel-make-openai
  	   "github-copilot"
  	   :host "api.githubcopilot.com/"
  	   :endpoint "chat/completions"
  	   :key 'gptel-api-key
  	   :stream t
  	   :models '((gpt-4o-2024-08-06 :name "gpt-4o-2024-08-06")
  		     (claude-3.5-sonnet :name "claude-3.5-sonnet")
  		     (claude-3.7-sonnet :name "claude-3.7-sonnet")
  		     (claude-3.7-sonnet-thought :name "claude-3.7-sonnet-thought")
  		     (o1-2024-12-17 :name "o1-2024-12-17")
  		     (o1-mini-2024-09-12 :name "o1-mini-2024-09-12"))
  	   :header (lambda ()
  		     `(("Authorization" . ,(format "Bearer %s" (funcall gptel-api-key)))
  		       ("Content-Type" . "application/json")
  		       ("Accept" . "application/json")
  		       ("Copilot-Integration-Id" . "vscode-chat")
  		       ("editor-version" . "vscode/1.84.2")
  		       ("editor-plugin-version" . "1.138.0")
  		       ("user-agent" . "GithubCopilot/1.138.0")))))

      (advice-add 'gptel--url-parse-response :around
  		(lambda (orig-fun backend proc-info)
  		  (let ((result (funcall orig-fun backend proc-info)))
  		    (when (and (stringp (cadr result))
  			       (string-match-p "HTTP/2 401" (cadr result)))
  		      (message "Token expired, refreshing and retrying...")
  		      (setq gptel-copilot--exchanged-token nil)
  		      ;; Get new token
  		      (funcall gptel-api-key)
  		      ;; Retry the request
  		      (let ((request-data (plist-get proc-info :request-data)))
  			(when request-data
  			  (gptel-request request-data))))
  		    result)))

      (defun test-gptel-token-refresh ()
        "Test gptel token refresh logic."
        (interactive)
        (message "=== Starting Token Test ===")
        (message "Current token (first 50 chars): %s..."
  	       (substring gptel-copilot--exchanged-token 0 50))
        ;; Force token refresh by setting to nil
        (setq gptel-copilot--exchanged-token nil)
        ;;(message "Cleared token, making request...")
        ;; Make request that should trigger token refresh
        ;;(gptel-request
         ;;"Test message"
         ;;:callback (lambda (response info)
  		   ;;(message "=== Request completed ===")
  		   ;;(message "New token (first 50 chars): %s..."
  			    ;;(substring gptel-copilot--exchanged-token 0 50))
  		   ;;(message "Response status: %s" (plist-get info :status))
  		   ;;(message "Got response: %s" response)))
        )

      (defun get-anthropic-api-key ()
        (when-let ((auth (car (auth-source-search
  			     :host "api.anthropic.com"
  			     :require '(:secret)))))
  	(let ((token (plist-get auth :secret)))
  	  (if (functionp token)
  	      (funcall token)
  	    token))))

      (gptel-make-anthropic "Claude"          
  			  :stream t                             
  			  :key #'get-anthropic-api-key)

      ;;(gptel-make-anthropic "claude" 
      ;;:key #'get-anthropic-api-key
      ;;:stream t
      ;;:models '(claude-3-7-sonnet-20250219)
      ;;:header (lambda () (when-let* ((key (gptel--get-api-key)))
      ;;`(("x-api-key" . ,key)
      ;;("anthropic-version" . "2023-06-01")
      ;;("anthropic-beta" . "pdfs-2024-09-25")
      ;;("anthropic-beta" . "output-128k-2025-02-19")
      ;;("anthropic-beta" . "prompt-caching-2024-07-31"))))
      ;;:request-params '(:max_tokens 4096))

      ;;(gptel-make-anthropic "claude-thinking" 
      ;;:key #'get-anthropic-api-key
      ;;:stream t
      ;;:models '(claude-3-7-sonnet-20250219)
      ;;:header (lambda () (when-let* ((key (gptel--get-api-key)))
      ;;`(("x-api-key" . ,key)
      ;;("anthropic-version" . "2023-06-01")
      ;;("anthropic-beta" . "pdfs-2024-09-25")
      ;;("anthropic-beta" . "output-128k-2025-02-19")
      ;;("anthropic-beta" . "prompt-caching-2024-07-31"))))
      ;;:request-params '(:thinking (:type "enabled" :budget_tokens 2048)
      ;;:max_tokens 4096))

      (setq gptel-backend gptel-copilot-backend
  	  ;;gptel-model 'gpt-4o-2024-08-06
  	  gptel-model 'claude-3.7-sonnet
  	  gptel-auto-save-directory "~/chats"
  	  gptel--mark-prompts-and-responses nil
  	  gptel-auto-save-buffers t
  	  gptel-prompt-prefix
  	  "You are an Emacs-integrated assistant for a Bitwarden software engineer.
  		    Be direct about uncertainties. Display files in org blocks with paths."
  	  gptel-default-mode 'org-mode))
#+end_src

* GPTel Context Management

These are helper functions and automations for being efficient with tokens in GPTel.

This doesn't work

#+begin_src emacs-lisp
  ;; Context minification function for GPTel
  (defun my/gptel-minify-context ()
    "Minify the current gptel chat buffer context to reduce tokens."
    (interactive)
    (when (derived-mode-p 'gptel-mode)
      (let ((inhibit-read-only t)
	    (modified (buffer-modified-p)))
	(save-excursion
	  ;; Remove excess blank lines
	  (goto-char (point-min))
	  (while (re-search-forward "\n\n\n+" nil t)
	    (replace-match "\n\n"))

	  ;; Collapse code blocks to show minimal context
	  (goto-char (point-min))
	  (while (re-search-forward "```\\([^`\n]*\\)\n\\([^`]*?\\)\n```" nil t)
	    (let* ((lang (match-string 1))
		   (code (match-string 2))
		   (lines (split-string code "\n"))
		   (total-lines (length lines))
		   (preview-lines 3)
		   (minified-code
		    (if (> total-lines (* 2 preview-lines))
			(concat
			 (string-join (seq-take lines preview-lines) "\n")
			 "\n... "
			 (number-to-string (- total-lines (* 2 preview-lines)))
			 " lines collapsed ...\n"
			 (string-join (seq-take-last preview-lines lines) "\n"))
		      code)))
	      (replace-match (format "```%s\n%s\n```" lang minified-code))))

	  ;; Optionally truncate very long responses
	  (goto-char (point-min))
	  (while (re-search-forward "^Assistant: \\([^\n]*\\(?:\n[^\n]+\\)*\\)" nil t)
	    (let* ((response (match-string 1))
		   (lines (split-string response "\n"))
		   (max-lines 20))
	      (when (> (length lines) max-lines)
		(let ((truncated-response
		       (concat
			(string-join (seq-take lines (/ max-lines 2)) "\n")
			"\n... "
			(number-to-string (- (length lines) max-lines))
			" lines summarized ...\n"
			(string-join (seq-take-last (/ max-lines 2) lines) "\n"))))
		  (replace-match (concat "Assistant: " truncated-response))))))

	  ;; Remove trailing whitespace
	  (delete-trailing-whitespace))

	;; Restore modification state
	(set-buffer-modified-p modified))

      ;; Provide feedback on reduction
      (message "Context minified. Use M-x revert-buffer to restore if needed.")))

  ;; Bind minification function in gptel-mode
  (define-key gptel-mode-map (kbd "C-c C-m") #'my/gptel-minify-context)
#+end_src

* GPTel Tools

This section defines agenic tools capabilities for gptel. It's my answer to the "stdlib for LLMs" idea.

Some notes:

1. All tools _must_ have an arguement. This can be just a dummy arguement like `read_gptel_tools_section`.

** General Tools Setup
This block contains helper functions and variables used by multiple tools. These are not tools themselves but support the tool infrastructure.

#+begin_src emacs-lisp
  (setq gptel-use-tools t
	gptel-tools nil)  

  (defun register-gptel-tool (tool-name)
    "Register a tool with gptel by its NAME."
    (add-to-list 'gptel-tools (gptel-get-tool tool-name)))


  (defvar my/file-bookmarks
    '(("emacs config" . (:path "~/nix/system/with/user/with/program/emacs.org"
			       :description "My literate org based emacs configuration"))
      ("inbox" . (:path "~/notes/inbox.org"
			:description "My inbox for my TODOs and notes"))
      ))
#+end_src

** Read File

This tool hooks in to my file reading function and bookmarks list to enable LLMs to edit specific files at will and all files behind a warning.

#+begin_src emacs-lisp
  (defun my/read-file (file-id)
    "Read complete contents of a file.
	  FILE-ID can be a bookmark name or full path."
    (let* ((bookmark (alist-get file-id my/file-bookmarks nil nil #'equal))
	   (file-path (expand-file-name
		       (if bookmark 
			   (plist-get bookmark :path)
			 file-id))))
      (with-temp-buffer
	(insert-file-contents file-path)
	(buffer-substring-no-properties (point-min) (point-max)))))

  (gptel-make-tool
   :name "read_file"
   :function #'my/read-file
   :description "Read a file's complete contents"
   :args '((:name "file-id"
		  :type string
		  :description "can be a full path or one of the following bookmarks:
	      - 'emacs config' for my emacs configuration
	      - 'inbox' for my org mode inbox file")
	   ))
  (register-gptel-tool "read_file")
#+end_src

** Write File

This tool hooks in to my file  writing function and bookmarks list to enable LLMs to edit specific files at will and all files behind a warning.

#+begin_src emacs-lisp
  (defun my/parse-search-replace-blocks (content)
    "Extract list of changes from content with search/replace blocks."
    (with-temp-buffer
      (insert content)
      (let (changes)
	(goto-char (point-min))
	(while (re-search-forward "<<<<<<< SEARCH\n\\([^=]*?\\)\n=======\n\\([^>]*?\\)\n>>>>>>> REPLACE" nil t)
	  (push (list :search (match-string 1)
		      :replace (match-string 2))
		changes))
	(nreverse changes))))

  (defun my/apply-changes (original-content changes)
    "Apply changes specified in search/replace block format to ORIGINAL-CONTENT."
    (with-temp-buffer
      (insert original-content)
      (dolist (change changes)
	(let ((search (plist-get change :search))
	      (replace (plist-get change :replace)))
	  (goto-char (point-min))
	  (while (search-forward search nil t)
	    (replace-match replace t t))))
      (buffer-string)))

  (defun my/write-file (file-id content)
    "Write file with changes in search/replace block format.
	    FILE-ID can be a bookmark name or full path.
	    CONTENT must contain search/replace blocks showing what to change."
    (let* ((bookmark (alist-get file-id my/file-bookmarks nil nil #'equal))
	   (file-path (expand-file-name
		       (if bookmark 
			   (plist-get bookmark :path)
			 file-id)))
	   (original (my/read-file file-id))
	   (changes (my/parse-search-replace-blocks content))
	   (new-content (my/apply-changes original changes)))
      ;; Check if content is unchanged
      (when (string= original new-content)
	(error "No changes detected - the diff would be empty"))
      ;; Validate content preservation
      (when (< (length new-content) (* 0.95 (length original)))
	(error "Error: New content is significantly smaller than original"))
      ;; Show git-style diff and confirm
      (let* ((temp-orig (make-temp-file "gptel-orig-"))
	     (temp-new (make-temp-file "gptel-new-"))
	     (diff-buffer (get-buffer-create "*File Changes Preview*"))
	     (confirm-changes nil))
	;; Write both versions to temp files
	(write-region original nil temp-orig)
	(write-region new-content nil temp-new)
	;; Generate and display diff
	(with-current-buffer diff-buffer
	  (erase-buffer)
	  (insert "Proposed changes to " file-path ":\n\n")
	  (call-process "git" nil t nil "diff" "--no-index" "--color=never" temp-orig temp-new)
	  ;; Enable diff-mode for syntax highlighting
	  (diff-mode)
	  (goto-char (point-min))
	  (display-buffer diff-buffer)
	  (setq confirm-changes (yes-or-no-p "Apply these changes? ")))
	;; Cleanup
	(delete-file temp-orig)
	(delete-file temp-new)
	(kill-buffer diff-buffer)
	(if confirm-changes
	    (progn
	      (write-region new-content nil file-path)
	      (format "Updated %s" file-path))
	  (format "Changes cancelled by user. Seek feedback before trying again!")))))

  (gptel-make-tool
   :name "write_file"
   :function #'my/write-file
   :description "Modify specific sections of a file while preserving all other content.

	  IMPORTANT: Always use read_file first to understand the current content and structure! 

	  The CONTENT arguement _must_ adhere to this format with SEARCH and REPLACE blocks:

	  <<<<<<< SEARCH
	  {text to find and replace}
	  =======
	  {new text to insert}
	  >>>>>>> REPLACE

	  - You can include multiple search/replace blocks to make multiple changes.
	  - The search text must match exactly what is in the file.
	  - If a failure occurs do not try again without asking me first.

	  After using write-file to modify files, evaluate whether the changes should be committed to version control. If the changes are in a git repository and represent a meaningful unit of work, follow up with a git_commit call with an appropriate commit message."
   :args '((:name "file-id"
		  :type string
		  :description "can be a full path or one of the following bookmarks:
	      - 'emacs config' for my emacs configuration

	      - 'inbox' for my org mode inbox file")
	   (:name "content"
		  :type string
		  :description "search/replace blocks showing what to change")))

  (register-gptel-tool "write_file")
#+end_src

** Fetch_Webpage

#+begin_src emacs-lisp
  (gptel-make-tool
   :name "fetch_webpage"
   :function (lambda (url)
	       (message "Fetching URL: %s" url)
	       (let ((buffer (url-retrieve-synchronously url t nil 30)))
		 (when buffer
		   (with-current-buffer buffer
		     (goto-char (point-min))
		     (re-search-forward "^$" nil t) ; Skip headers
		     (forward-char)
		     ;; Basic HTML cleanup: Convert to plain text
		     (require 'shr)
		     (let* ((dom (libxml-parse-html-region (point) (point-max)))
			    (text-buffer (generate-new-buffer " *temp*")))
		       (with-current-buffer text-buffer
			 (shr-insert-document dom)
			 ;; Clean up the text and ensure it's JSON-safe
			 (let ((content (replace-regexp-in-string 
					 "[\u0000-\u001F\u007F]+" " "
					 (buffer-substring-no-properties (point-min) (point-max)))))
			   (kill-buffer text-buffer)
			   (kill-buffer buffer)
			   ;; Ensure we return a proper JSON string
			   content)))))))
   :description "fetch the contents of a webpage given its url"
   :args '((:name "url"
		  :type string
		  :description "url of the webpage to fetch"))
   :category "web")

  (register-gptel-tool "fetch_webpage")
#+end_src

** Git_Commit

#+begin_src emacs-lisp
  (defun my/git-commit-changes (project message)
    "Commit all changes in the specified project repository with the given message."
    (let* ((project-root (if (file-name-absolute-p project)
			     project
			   (let ((found (seq-find (lambda (p)
						    (string-match-p project (file-name-nondirectory p)))
						  projectile-known-projects)))
			     (or found (error "Project not found: %s" project)))))
	   (default-directory project-root)
	   (status (shell-command-to-string "git status --porcelain")))
      (if (string-empty-p status)
	  "No changes to commit"
	(shell-command-to-string (format "git add -A && git commit -m %s"
					 (shell-quote-argument message))))))

  (gptel-make-tool
   :name "git_commit"
   :function #'my/git-commit-changes
   :description "Commits all changes in the specified Git repository."
   :args '((:name "project"
		  :type string
		  :description "project name or full path to git repository")
	   (:name "message"
		  :type string
		  :description "commit message"))
   :category "git")

  (register-gptel-tool "git_commit")
#+end_src

** Create_File

#+begin_src emacs-lisp :tangle no
  (gptel-make-tool
   :name "create_file"
   :function (lambda (path content)
	       (let ((dir (file-name-directory path)))
		 (condition-case err
		     (cond
		      ((file-exists-p path)
		       (error "File already exists: %s" path))
		      (t
		       (when dir
			 (make-directory dir t))
		       (write-region content nil path)
		       (format "Successfully created file: %s" path)))
		   (error
		    (format "Error creating file: %s" (error-message-string err))))))
   :description "Creates a new file with specified content, creating any necessary parent directories. Will not overwrite existing files."
   :args '((:name "path"
		  :type string
		  :description "path to the file to create")
	   (:name "content"
		  :type string
		  :description "content to write to the file"))
   :category "file")
#+end_src

** Project Context Tool

#+begin_src emacs-lisp
  (defun my/project-context-for-llm (project-root &optional scope)
    "Generate project context for LLM consumption.
	PROJECT-ROOT is the directory to analyze.
	SCOPE can be 'structure (directory only), 'core (key files), or 'full (both)."
    (let* ((project-root (expand-file-name project-root))
	   (default-directory project-root)
	   (context-parts '()))

      ;; Add project structure with depth limitation
      (push (concat "Project Structure:\n" 
		    (shell-command-to-string "tree -L 3 --gitignore --noreport"))
	    context-parts)

      ;; Add key files only for core or full scopes
      (when (or (eq scope 'core) (eq scope 'full))
	(let* ((key-files '("README.md" "package.json" "Cargo.toml" "pyproject.toml"
			    "flake.nix" "default.nix" "home.nix"
			    "Makefile" "justfile"))
	       (found-files '()))

	  ;; Find important files that actually exist
	  (dolist (file key-files)
	    (when (file-exists-p file)
	      (push file found-files)))

	  ;; Add file summary header
	  (push "\nKey Files Found:" context-parts)
	  (push (mapconcat #'identity found-files "\n") context-parts)

	  ;; Add content of files with size checks and truncation
	  (push "\nFile Contents:" context-parts)
	  (dolist (file found-files)
	    (let ((file-size (nth 7 (file-attributes file))))
	      (cond
	       ;; Skip large files completely
	       ((> file-size 15000)
		(push (format "\n=== %s === (TOO LARGE: %dKB - skipped)" 
			      file (/ file-size 1024)) 
		      context-parts))

	       ;; Truncate medium files
	       ((> file-size 5000)
		(push (format "\n=== %s === (TRUNCATED: %dKB)" 
			      file (/ file-size 1024)) 
		      context-parts)
		(push (with-temp-buffer
			(insert-file-contents file nil 0 2000)
			(concat (buffer-string) 
				"\n[...file truncated...]\n"))
		      context-parts))

	       ;; Include small files completely
	       (t
		(push (format "\n=== %s ===" file) context-parts)
		(push (with-temp-buffer
			(insert-file-contents file)
			(buffer-string))
		      context-parts)))))))

      ;; Join all parts in reverse order (since we used push)
      (mapconcat #'identity (reverse context-parts) "\n")))

  (gptel-make-tool
   :name "project_context"
   :function #'my/project-context-for-llm
   :description "Get structural and content context for a project directory"
   :args '((:name "project"
		  :type string
		  :description "project name or path")
	   (:name "scope"
		  :type string
		  :description "context scope: 'structure, 'core, or 'full"))
   :category "project")

  (register-gptel-tool "project_context")
#+end_src

* Path Copying Functions

#+begin_src emacs-lisp
  (defun copy-file-path ()
    "Copy the current buffer file path to the kill ring."
    (interactive)
    (let ((filepath (buffer-file-name)))
      (when filepath
        (kill-new filepath)
        (message "Copied: %s" filepath))))

  (defun copy-file-name ()
    "Copy the current buffer file name to the kill ring."
    (interactive)
    (let ((filename (file-name-nondirectory (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied: %s" filename))))

  (defun copy-directory-path ()
    "Copy the current buffer directory path to the kill ring."
    (interactive)
    (let ((dirpath (file-name-directory (buffer-file-name))))
      (when dirpath
        (kill-new dirpath)
        (message "Copied: %s" dirpath))))
#+end_src

* Provide Init

#+begin_src emacs-lisp
  (provide 'init)

  ;; Local Variables:
  ;; byte-compile-warnings: (not free-vars)
  ;; End:
	    ;;; init.el ends here
#+end_src


